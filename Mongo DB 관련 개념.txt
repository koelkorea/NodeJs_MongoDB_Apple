- DB(DataBase)
   : 데이터를 대량으로 영구적으로 보관 + 그 데이터를 빠르게 입/출력 하는데 특화 + 여러 사용자가 공유하여 사용할수 있는 통합해서 저장한 운영 데이터의 집합
      -> 일반적으로 데이터베이스 관리 시스템(DBMS)에 의해 제어

     # 관계형을 기준으로 본 DB의 종류
        1. 관계형 데이터베이스 (RDBMS)
            : 각 데이터들이 1개 이상의 '행 : 열' = 'key : value' 관계로 이뤄진 테이블 형식의 스키마에 저장되어 있는 DB
              (= 각 테이블 간 다른 데이터 구조가 어떻게 관련되어 있는지 외래키(= Foreign Key)를 기준으로 명확하게 정규화되어 정의되어 있기에, 쉽게 파악하고 이해 가능)
                  -> 정규화(normal form) 되어 있기에, 데이터 입/출력의 정확도가 뛰어난 편

                      EX) MySQL, PostgreSQL, Oracle, SQLite, MSSQL
                           -> 아주 대부분의 프로젝트들이 사용하는 DB들이 다 여기 있으며, SQL 사용

        
        2. 비관계형 데이터베이스 (NoSQL)
            : 1과 같은 테이블 형식의 스키마를 사용하지 않는 DB
              (= 명확하고 정확도는 기대 못하지만? 자유롭게 이용가능하며, JSON형식과 유사하게 사용 가능)
                  -> 정규화 안해도 되서 단순하고 빠르지만, 데이터 입/출력이 정확하지 않아, 정교한 조직이나 수정이 힘들다

                      EX) MongoDB, Redis

     # 정규화 여부를 기준으로 본 DB의 종류
        1. 정규화 데이터베이스(normalized database)
            : 데이터 간 중복을 최소화하도록 설계된 DB
               -> 공간적으로는 효율적이지만, 시간적으로는 수시로 JOIN처리를 해야해서 상대적으로 느린 단점이 존재
        
        2. 비정규화 데이터베이스(denormalized database)
            : 읽는 시간을 최적화하도록 설계된 DB
               -> 공간적으로는 비효율적이지만, 시간적으로 빠르고 규모 확장성이 높다는 장점이 존재하며


- 정규화(Normalized)와 비정규화(denormalized) 
   : 대부분의 규모 확장성(scalability)을 요구하는 시스템의 경우, 여러가지 이유로 2가지를 혼용하여 섞어 사용

     1. 정규화(Normalized)
         : (관계형 데이터베이스 (RDBMS)에서만 사용 가능) DB를 구성하는 테이블(= collection)들의 칼럼(= field)구성에 있어, 중복성과 종속성을 줄이는 최소화하기 위해 데이터를 구조화하여 정규형(normal form)로 만드는 작업
            -> 테이블과 테이블의 중복저장되는 종류의 데이터를 가지는 칼럼들이 존재하는 낭비와 그런 데이터들이 부분적인 갱신으로 인한 문제를 해결하고자 도입하는 것
   
           # (중요) 구체적으로 어떻게 구현?
              1) 테이블들을 관리하기 쉬운 작은 테이블들로 나눈 뒤
              2) 쪼개진 각 테이블의 데이터들은 중복되지 않고, 서로를 구분 가능한 주요 속성을 가진 칼럼인 기본 키(= Primary key)를 가지고 있어야 함
                  -> 제 1 정규화(= 1NF)
              3) 쪼개진 각 테이블의 기본 키(= Primary key)가 아닌 비주요 칼럼들은 기본 키(= Primary key)와 직접적으로 의미적인 종속관계를 가져야 함
                  -> 제 2 정규화(= 2NF)
              4) 3)의 비주요 칼럼들은 제 각각 서로간 어떠한 종속관계를 의미적으로 가지는 경우가 있다면, 그 칼럼들중 일부는 관계성이 사라질 때까지 테이블에서 퇴출되어야 함
                  -> 제 3, 4 정규화(= 3NF)
              5) (중요!) 쪼개진 테이블 간 관계성을 가지는 경우는, 테이블 간 연결되는 데이터 칼럼인 Foreign Key(= 외래키)을 생성하여 해결
                  -> 제 5 정규화(= 5NF)
                  -> 이를 통해 필요하고 연관된 다른 테이블의 칼럼값들을 전부 데이터로 뽑을 수 있게 함
                     (= 이 과정에서 이용하는 방식이 2개의 테이블을 참조하고, 거기서 공통값들을 조건을 통해 뽑아내는 join과 같은 방법은 관계형DB에서만 가능)    
   
           # 정규화의 원칙
              1) 정보의 무손실 표현 
                  : 스키마를 다른 스키마로 변환할 때, 정보의 손실이 있어서는 안 됨
                    (= 정규화의 결과로 JOIN을 해도 원본 데이터가 소실되지 않고 가져올 수 있는 방향으로 DB설계를 해야 함)
   
              2) 분리의 원칙 (2NF, 3NF 관련)
                  : 테이블에 PK와 관련없거나, 있더라도 다른 nonPK와 연관이 있는 칼럼들은 독립된 테이블로 분리해놔야 함
   
              3) 데이터의 중복성이 감소되어야 함 (1NF 관련)
   
           # 정규형(normal form)의 단계
              : DB 설계에 있어 어떤 조건을 만족했는지에 따라, 정규화의 수준이 주로 3단계로 나눠지며, 높은 단계일수록 정규화가 잘된것을 의미함
                (= 3단계가 되면 4, 5 단계는 거의 만족하는 곁다리에 가까움)
                
                1) 1정규형 (1NF)
                    : DB의 각 테이블 모든 칼럼은 반복 그룹이 존재해서는 안되며, 원자적인 값(= 1개의 값)을 가지고 있어야 한다는 원칙
                      (= 여기서, 대부분의 중복, 반복적으로 흘러가는 부분들은 전부 다듦을수 있음)
      
                       ex) 제 1 정규형 (1NF) 충족 X
                            : 고객명, 주문상품 칼럼에 들어간 데이터가 복수개이기 때문
      
                              주문번호 |    고객명     |   주문상품           ->    주문번호 | 고객명 | 주문상품
                                 1    | 홍길동, 김철수 | 사과, 바나나                  1    | 홍길동 |   사과   
   
                       ex) 제 1 정규형 (1NF) 충족 X
                            : 회원번호, 고객명, 별명에 반복되기에, 반복되는 부분을 다른 테이블로 나누어 원래 존재하는 부분의 칼럼수를 줄임
      
                              주문번호 | 회원번호 |  고객명 | 별명 | 주문상품           ->    회원번호 | 고객명 | 별명
                                 1    |    1    |  홍길동 | 악마 |   사과                      1    | 홍길동  | 악마
                                 2    |    1    |  홍길동 | 악마 |  바나나                     2    | 김철수  | 사람
                                 3    |    2    |  김철수 | 사람 |   사과         
                                                                                           주문번호 | 주문상품 | 회원번호
                                                                                              1    |   사과   |    1
                                                                                              2    |  바나나  |    1
                                                                                              3    |   사과   |    2
                2) 2정규형 (2NF) (= 부분 종속 제거)
                    : DB의 각 테이블은 서로 구분 가능한 주요 속성을 가진 칼럼인 기본 키(= Primary key)를 기준으로 모든 비주요 속성에 해당하는 칼럼들이 의미적으로 완전히 종속되어야 함
                      (= 테이블의 개념 주체는 기본 키(= PK)를 가진 칼럼을 기준으로 나머지 칼럼들이 의존하는 의미를 가져야 한다는 것)
      
                       ex) 제 2 정규형 (2NF) 충족 X
                            : 주문 테이블의 기본키(= PK)를 가진 칼럼은 주문번호로 이는 주문을 구분하는 주요개념이나..
                              BUT! 가격 정보를 나타내는 칼럼은 주문 테이블의 기본키(= PK)값을 가진 주문번호에 의미적으로 종속X, 상품명이 무엇인지에 따라 달라지는 값을 가진 개념
                               -> 상품 테이블을 따로 만들고, 상품 테이블의 기본키(= PK)는 상품명 칼럼을 지정하여, 상품명을 주요 속성 개념으로 정의하며, 주문 테이블과의 관계는 주문 테이블의 상품명 칼럼을 외래키(= FK)로 지정하여 주문 테이블과 연결해 해결
   
                              주문번호 | 상품명 |  가격             ->    주문번호(PK) | 상품명(FK) 
                                 1    | 사과   |  1000                      1        | 사과
                                 1    | 바나나 |  1500                      1        | 바나나
   
                                                                        상품명(PK, FK) | 가격
                                                                              사과     | 1000
                                                                             바나나    | 1500
                3) 3정규형 (3NF) (= 이행 종속 제거)
                    : DB의 각 테이블의 모든 비주요 속성에 해당하는 칼럼들과 테이블의 기본 키(= Primary key)와 의미적인 종속관계인 2정규형(= 2NF)을 만족한다 쳐도, 비주요 속성 간 종속성들이 존재(= 이행적 종속)한다면 이는 제거되어야 함
                      (= 2정규형을 만족하는 DB설계에서 각 테이블의 비 PK칼럼들간 종속성이 보이면 이거도 모두 제거해야 함)
   
                    서로 구분 가능한 주요 속성을 가진 칼럼인 기본 키(= Primary key)를 기준으로 나머지 모든 비주요 속성에 해당하는 칼럼들이 의미적으로 완전히 종속되어야 함
                      (= 테이블의 개념 주체는 기본 키(= PK)를 가진 칼럼을 기준으로 나머지 칼럼들이 의존하는 의미를 가져야 한다는 것)
   
                          ex) 제 3 정규형 (3NF) 충족 X
                            : 부서명, 부서위치 모두 직원 테이블의 기본값(= PK)를 가진 칼럼인 직원번호와 종속적 관계지만..
                              BUT! 비주요 속성 칼럼인 부서위치, 부서명은 부서위치가 부서명에 다른 한편으로 또 종속성을 가짐
                               -> 부서 테이블을 따로 만들고, 부서 테이블의 기본키(= PK)는 부서명 칼럼을 지정하여, 부서명을 주요 속성 개념으로 정의하며, 사원 테이블과의 관계는 사원 테이블의 부서명 칼럼을 외래키(= FK)로 지정하여 부서 테이블과 연결해 해결
   
                              직원번호 | 부서명 | 부서위치             ->    직원번호 | 부서명
                                101   | 판매부 |  서울                        101   | 판매부
                                102   | 회계부 |  부산                        102   | 회계부 
   
                                                                            부서명 | 부서위치
                                                                            판매부 |  서울
                                                                            회계부 |  부산
   
                4) (안 중요) 4정규형 (4NF)
                    : DB의 각 테이블들은 다치 종속성(= 1개의 칼럼의 데이터가 다른 칼럼의 데이터와 1:N으로 대응하는 경우)을 없애야 함
                       -> 데이터들의 원자화 1정규형, non PK 칼럼들은 모두 PK칼럼에 의미적 종속관계 성립의 2정규형, 그 외 모든 non PK들 간의 종속성 삭제의 3 정규형을 모두 거치면 당연히 이런 경우는 사라짐
   
                5) (안 중요) 5정규형 (5NF)
                    : DB의 모든 테이블과 칼럼들이 조인 종속성(= )까지 제거되어, 이 이상으로 쪼개거나 나누면, 오히려 문제가 생기는 형태를 의미
                       -> 쉽게 말해, 존재하는 모든 테이블에 FK값을 통해 원래 존재했던 모든 형태로 데이터를 복원이 가능하게 설계된 경우라고 생각하면 됨
   
           # 정규형(normal form)의 장/단점
   
              @ 장점
                 1) 비정규화 DB는 겪는 이상 현상(Anomaly)이라는게 없음
                 2) 저장 공간의 최소화
                 3) 효과적인 검색 알고리즘 생성
                 4) 테이블간 칼럼 간 이미 구조가 최적화 되었으니, 데이터 투입에 별 고민 안해도 됨
                 5) 데이터 구조의 안정성 및 무결성 유지
   
              @ 단점
                 1) 뭐 할때마다 JOIN 연산이 필요한 경우가 많음
                    (= 이로 인한 질의에 대한 응답 시간 저하)
   

     2. 비정규화(Denormalized)
         : 의도적으로 정규화 원칙을 위배하여 JOIN ㅈ까는 방향으로 테이블의 칼럼을 배치하는 DB설계 과정을 의미
             -> 테이블 간 중복, 반복되는 데이터가 보이더라도 개발이던 DB성능이건 속도라는 관점에서 다 용서하는 관점에서 진행함
                (= join을 상정하지 않기에, 애초에 join 기능 사용이 불가능함.. 따라서 테이블(=collection)에 필요한건 다 때려넣는다는 각오가 있어야 함)
               
   
                ex) 이런식으로 고객명, 별명이 중복, 반복되어도 전부 허용함... 애초에 join을 상정한거도 아님
   
                    주문번호 | 회원번호 |  고객명 | 별명 | 주문상품           ->    회원번호 | 고객명  | 별명
                       1    |    1    |  홍길동 | 악마 |   사과                      1    | 홍길동  | 악마
                       2    |    1    |  홍길동 | 악마 |  바나나                     2    | 김철수  | 사람
                       3    |    2    |  김철수 | 사람 |   사과         
   
           # 비정규화 대상
              : 그러니까 기술적으로 JOIN처리하기 힘들고, 처리 범위도 넓고 사용 빈도도 높아서 정규화보단 닥치고 성능이 중요한 부분이 주요 타겟

                1) 자주 사용되는 테이블에 액세스하는 프로세스의 수가 가장 많음
                2) 항상 일정한 범위만을 조회하는 경우
                3) 테이블에 대량 데이터가 있고 대량의 범위를 자주 처리하는 경우, 성능 상 이슈가 있을 경우
                4) 테이블에 지나치게 조인을 많이 사용하게 되어 데이터를 조회하는 것이 기술적으로 어려울 경우

           # 정규형(normal form)의 장/단점
   
              @ 장점
                 : JOIN X라 성능, 복잡성 부분에서 이득
                     -> 빠른 데이터 조회
                     -> 살펴볼 테이블이 줄어들기 때문에 데이터 조회 쿼리가 간단
                        (= DB 설계시간 단축으로 개발속도 빠름 + 버그도 줄어듦)
   
              @ 단점
                 1) 이상 현상(Anomaly) 발생에 따른 문제
                     - 데이터 갱신이나 삽입 비용이 높음
                     - 데이터 갱신 또는 삽입 코드를 작성하기 어려워짐
                     - 데이터 간의 일관성, 무결성이 깨어질 수 있다. 어느 쪽이 올바른 값인가?
   
                 2) 데이터를 중복하여 저장하므로 더 많은 저장 공간이 필요
   
           # 이상현상(Anomaly)
              : 중복된 정보로 인해 발생하는 문제로... 정규화를 통해서 밖에는 해결이 불가능함! 
                (= 비정규화 DB쓰면 절대 헤어나오지 못함)
   
                1) 입력 이상(Insertion Anomaly)
                   : 원하지 않는 자료가 입력 or 입력하는데 자료가 부족해 삽입이 되지 않아 발생하는 문제점
                
                2) 삭제 이상(Deletion Anomaly)
                   : 하나의 자료만 삭제하고 싶지만, 그 자료가 포함된 튜플 전체가 삭제됨으로 원하지 않는 정보 손실이 발생하는 문제점
                
                3) 갱신 이상(Modification Anomaly)
                   : 정확하지 않거나 일부의 튜플만 갱신되어 정보가 모호해지거나, 일관성이 없어져 정확한 정보 파악이 되지 않는 문제점
                      -> 비정규화 DB를 쓰다보면, 이 문제가 참 골칫거리임


- MongoDB
   : 비관계형 데이터베이스 DB 중 하나
     (= 관계형 DB가 아님 = 비정규화를 권장하는 DB = 테이블 2개 참조해서 무결성 데이터 뽑는 JOIN 같은거 애초에 고려도 안 함)

      # MongoDB 구조 종류
         : document 데이터베이스 = Database -> collection(= Table) -> document(= Data)단위를 기준으로 한 document당 js객체와 같은 형식으로 구성
            -> 코드짜던 js 객체 내용 그대로 데이터베이스에 밀어넣을 수 있어서 매우 저장과 출력이 편리
     
                ex) Database 예시

                    1. collection (테이블)
                       { name : 'kim'
                         age  : 20   }     <- document (데이터 단수)
            
                       { name : 'lee'
                         age  : 21   }     <- document (데이터 단수)
    
                    2. collection (테이블)
                       { goods   : 'apple'
                         quality : 3   }     <- document (데이터 단수)
            
                       { goods   : 'peer'
                         quality : 8   }     <- document (데이터 단수)

      # Collection
         : MongoDB에서 기존 관계형 DB에서 사용하는 Table 단위와 비슷한 개념으로 존재하는 폴더.. 
            -> 이를 기준으로 각 DB는 자신 안의 데이터들을 저장할 위치를 구분함

      # MongoDB 사용법
         1. 설치해서 쓰기
         2. mongodb.com 클라우드에서 호스팅받기 (추천)
             -> 클라우드라 따로 생성 필요X
             -> 무료용량 제공
             -> full text search index 기능 제공
             -> 돈을 내면, replica set이라고 해서 자동으로 3개의 데이터베이스에 분산저장 및 백업 제공

                [mongodb.com에서 호스팅받는 법]
   
                 1) mongodb.com 가입 후, 설문
                 2) 무료 티어 선택 + 위치는 서울 추천 
                 3) create! 후, 좌측 Database Access 메뉴에서 해당 클라우드 DB 접속용 아이디/비번을 만듦
                     -> (주의!) mongodb.com 계정이 아니라, 해당 db서버 계정에 대한 것임
                 4) Bulit-in role에 atlas admin으로 설정
                     -> (중요) 이렇게 해줘야, nodejs에서 DB 접속시 온갖 것들을 다 사용가능
                 5) 좌측 Network Access 메뉴에서 IP를 추가하여, 데이터베이스 접속할 수 있는 IP를 미리 정의해놓는 일종의 보안 설정
                     -> 보안 필요없이 아무데서나 쓸거면, Allow access from anywhere을 누르시거나 0.0.0.0/0 을 추가
                 6) create DataBase를 통해, DB의 이름과 collection의 이름을 정하고 생성
                     -> (중요) 이렇게 PROJECT > DB > collection > document(= db의 행에 해당하는 개별 데이터)의 위계를 따르게 됨
                 7) 웹서버와 해당 MongoDB 연결

      # index(인덱스) 개념
         : 어떤 DB의 table(= collection) 데이터들을 어떤 정렬기준을 가지고 정렬시켜 놓은 버전의 복사본
             -> 이를 기반으로 DB의 데이터들을 조건에 맞게 검색하고 뽑는 작업속도와 효율을 늘리는 목적으로 제작함

           @ index의 특징
              1. (중요) 보통 검색에 사용하는 알고리즘은 '이진검색(binary search)'이거나 그보다 빠른 알고리즘으로 시간복잡도는 O(log n)보다 빠르다고 보면 됨
              2. index에 반영된 필드(= 칼럼)이 여러가지인 compound index도 존재함
              3. (MongoDB 한정) 각 Collection은 기본적으로 _id 순으로 정렬해둔 index가 있음

           @ index의 단점
              : 어쨌거나 편리한 만큼 공간적 시간적 댓가가 필요하니, 검색작업이 많은 필드들만 index 만들어두는게 비용적으로 이득

                 1. 결국 하드웨어에 이를 저장할 용량을 필요로 함
                    (= index는 정렬기준을 가지고 정렬시켜 놓은 버전의 복사본)
   
                 2. collection(= table)의 document(= data)의 CUD시 index에도 이를 반영해줘야 함
                    (= index가 너무 많으면, CUD 작업할 때마다 동반되는 작업이 너무 많음)

                 3. (mongoDB 한정) 문자(= text)로 정렬한 index는 정확한 단어 검색에 밖에 사용이 불가능 (= 조사가 많이 붙는 언어들은 쓰기가 힘듦)
                       -> index 제작시 데이터들을 띄어쓰기를 기준으로 독립된 단어들로 구분한 뒤, 검색어와 100% 일치하는 단어가 있는지 없는지 여부로 검색을 수행하기 때문
                           -> full text index (= search index) 라는 개념이 필요

      # search index (= 타 DB에서 full text index) 개념
         : MongoDB에서 문자를 100%가 아니라 부분적으로 포함될 경우라도 검색결과에 포함할 용도로 만들어진 index 
           (= 일반적으로 생각하는 검색기능에 부합할 수 있도록 제작된 정렬기준으로 제작된 index)

           @ search index 제작과정 및 동작 원리
              1. index를 만들 때 document(= 데이터)에 있는 특정 칼럼(= 필드)에 있는 문장들을 가져와서 조사, 부호 등 쓸데없는 불용어들을 다 제거

                  ex) 영어 기준   : 문장의 단어 중 and or the ~s 
                  ex) 한국어 기준 : 을, 를, 이, 가, 그리고, 또는 

              2. 1번의 과정을 거쳐 등장한 단어들을 다 뽑아서 정렬한 목록 제작
                 (= 해당 단어들을 목록에서 쉽게 빠르게 찾을 수 있으며, 이를 3번과정에서 부분검색기능에 활용하도록 하는 포석)

              3. 2번의 목록에서 해당 단어들이 어떤 document에 등장했는지와 연관된 필드를 만들고, 해당 단어가 등장한 document id같은걸 함께 단어 옆에 기재
              4. 검색을 하면 해당 index 목록을 참고하여, 검색어에 따른 document를 찾아서 클라이언트 측에 제공
                  -> seafood chicken 이렇게 검색하면, seafood와 chicken을 earch index에서 각각 검색하여, 그것이 존재하는 document를 도출하고, 이를 검색함수 find에 넣어서 결과를 도출해 클라이언트 측에 제공 
              
                     ex) <document>
                          _id : 1
                          title : Seafood and restaurants

                          _id : 2
                          title : Seafood and chicken

                          _id : 3
                          title : the game reviews~!

                         <제작된 search index>
                          단어         존재하는 docu ID
                          chicken      2
                          game         3
                          restaurant   1
                          review       3
                          seafood      1, 2                <- seafood를 검색한다면, 그것이 _id 1, 2에 존재한다는걸 알수 있기에, 이를 검색함수 find에 넣어서 결과를 도출해 클라이언트 측에 제공

           @ search index 특징
              1. 찾아온 document가 좀 많으면 내부적으로 중요해보이는 document들을 맨 위로 올려서 가져와줌
              2. 검색어 자동완성기능, 유사단어 검색기능 이런 것도 설정 가능


      # (선택) MongoDB에서 index(인덱스) 관련 

        1. 일반 index
      
           @ index 생성법
              1. server.js의 API를 통해 mongodb 라이브러리의 명령어로 만들기
                1) client.db('DB명').collection('컬렉션명').createIndex({ 필드명1 : 데이터타입 , ... , 필드명n : 데이터타입 })
                     -> 1은 숫자를 오름차순(= -1은 내림차순) 기준으로 정렬, text는 글자를 기준으로 정렬하라는 의미
    
              2. mongodb에서 collection을 특정 기준으로 정렬해 둔 복사본 index 만드는 법 (추천)
    
                1) 원하는 collection -> index ->  create index 클릭
                2) 페이지의 text 필드의 {} 안에 다음과 같은 형식으로 원하는 collection의 field명과 정렬의 기준으로 삼을 데이터 타입(숫자 = 1 or -1, 글자 = text)을 적음
                    -> { 필드명1 : 데이터타입 , ... , 필드명n : 데이터타입}
    
                        ex) { number : 1, ... , name : text }  
                              -> 1은 숫자를 오름차순(= -1은 내림차순) 기준으로 정렬, text는 글자를 기준으로 정렬하라는 의미
   
           @ (중요) 만들어진 index server.js에서 활용하는 코드
              1. (중요) index를 사용한 document 검색 코드
                  : index의 정렬기준이.. text(문자)인 경우? 
                     -> MongoDB의 find()나 findOne()에 예약어 $text : { $search: '검색어' } 을 기입하여 검색에 index를 사용함
                        (= index의 정렬기준이 숫자(-1 or 1)인 경우는 걍 신경꺼도 됨)
    
                        ex) (문자) db.collection().find( { $text : { $search: '안녕' } } ).explain('executionStats')
                              -> index 데이터타입이 문자의 경우 $text : { $search: '검색어' } 을 기입하여 검색에 index를 사용하여 검색
   
                            (숫자) db.collection().find( { text : '안녕' } ).explain('executionStats')
                              -> index 데이터타입이 -1 or 1(숫자)인 경우는 걍 신경꺼도 됨
                             
              2. (선택) 만약 성능측정 결과가 필요하다면, MongoDB의 CRUD 코드 중, find()나 findOne() 결과값 Cursor변수.explain('executionStats')를 붙여준 뒤 이를 출력함
    
                   ex) let stats = db.collection().find( { title : '안녕' } ).explain('executionStats');
                       console.log(stats);
                      
                        -> "executionStats" : {
                             "executionSuccess" : true,
                             "nReturned" : 10,
                             "executionTimeMillis" : 0,
                             "totalKeysExamined" : 10,
                             "totalDocsExamined" : 10,               <- 실제로 검색시 까본 collection의 데이터는 10개
                             "executionStages" : {
                               "stage" : "FETCH",                    <- "stage" : "FETCH" : 사용된 index가 collection의 모든 필드를 대상으로 했음
                               "nReturned" : 10,
                               "docsExamined" : 10,
                               "inputStage" : {
                                 "stage" : "IXSCAN",
                                 "nReturned" : 10,
                                 "indexName" : "class_1_grade_1"    <- "indexName" : "class_1_grade_1" : 사용한 index명
                               }
                             }
                           } 
   
                     [참고내용]
                       - totalDocsExamined: 참조된 document 횟수
                       - executionStages  : 쿼리 수행 상세 정보 객체
                          1) stage : 어떤식으로 작업을 했는가?
                              -> inputStage가 executionStages의 멤버객체 X
                                   A. TEXT_MATCH : TEXT 일치여부 기준으로 스캔
                                   B. COLLSCAN   : index를 사용X, 콜랙션의 데이터 전체 스캔(Collection Scan)
   
                              -> inputStage가 executionStages의 멤버객체로 생성
                                   A. SORT : find() 이후 SORT 함수를 사용하였으나, 해당 collection의 모든 필드가 정렬기준이 마련되지 않아 일부만 index가 적용된 경우
                                       -> inputStage 멤버객체의 stage멤버변수는 "SORT_KEY_GENERATOR"라는 상태값을 가지고, 부분적으로 적용된 index가 있다면, 하위 indexName을 가지는 inputStage 멤버객체가 존재함
                                   B. FETCH : find() 이후 SORT 함수를 사용하고, 해당 collection의 모든 필드가 적용된 compound index가 존재하여 사용 하는 경우 
                                       -> inputStage 멤버객체의 stage멤버변수는 "IXSCAN"라는 상태값을 가지며, indexName라는 멤버변수를 가짐 
   
                          2) inputStage : stage에서 선택한 방식의 세부사항을 적음

        2. search index 관련

           @ search index 생성법 (로컬 download로는 생성 불가!)
              1. MongoDB 사이트의 collection -> index -> search index 만들기(= create) 버튼 클릭
              2. index 이름은 자유롭게 작명, 어떤 collection의 index인지를 선택 후 next버튼 클릭 후 refine 클릭
              3. index를 커스터마이징 하는 부분에서 다음과 같이 설정
                  - analyzer : lucene.korean
                  - dynamic mapping : off
                     -> lucene.korean
                         : 각 document의 필드의 있던 document 분석시 lucene이라는 라이브러리를 이용해서 '한국어' 기준 쓸데없는 불용어나 조사를 제거해주라고 설정
                     -> dynamic mapping 
                         : 각 document에 있는 모든 필드들을 indexing할 것인지 결정 
                           (off를 하면? 5번의 field mapping을 직접 작성 = index 적용 필드를 직접 설정한다는 의미)
   
              4. (dynamic mapping : off를 설정시) Add field mapping을 클릭
                  -> 이후, 어떤 field(= column)를 기준으로 search index를 만들 것인지 설정하는 field mapping 추가
                     (= 검색어 입력시 검색의 대상이 되어야할 field(= column)들을 정확히 설정하여 검색의 범위를 정확히 설정해야 성능 낭비가 없음)
   
              5. search index 생성 이후 편의기능
                  -> query 버튼을 누르면 직접 검색 잘 되는지 테스트 가능
                  -> search index에 존재하는 단어 중 자주 검색되는 단어는 높은 score를 가짐
                     (= 높은 score 가진 document를 자동으로 위로 올려주기 때문에, 검색 순위같은 것도 자동 구현 가능)

           @ (중요) 만들어진 search index server.js에서 활용하는 코드
              : client.db('프로젝트명').collection('컬렉션명').aggregate()
                 -> .find()와 유사.. BUT! ()안에 여러 조건식을 [{조건1}, {조건2} ... ] 형식으로 적용을 원할 때 사용

                 [참고내용] 

                  1.(중요!) AggregationCursor 개념 ( <-> cursor)
                     : aggregate() 함수가 반환하는 return값으로 cursor와는 호환되지 않는 고유한 타입의 객체
                       (= 다른 CRUD 함수들이 체이닝할 수 있는 count() 같은 몇몇 함수들이 호환되지 않음!!)
                           -> count 같은 경우는 toArray()를 통해 객체배열로 변환한 뒤, length 멤버 변수를 통해 구함

                  1. aggregate() 안의 [{조건1}, {조건2} ... ] 으로 들어가는 객체배열의 각 객체요소는 반드시 연산자가 들어가 있어야 함
                      -> 3항연산자를 통해서 검색어가 NULL이나 ''인 경우를 [{}]안에서 쓸 수 없음 

                  2 검색파이프라인
                     : aggregate() 안의 [{조건1}, {조건2} ... ] 으로 들어가는 객체배열
                        -> 검색파이프라인 특성
                            a. 검색파이프라인 내부에 존재하는 연산자 조건을 담은 객체 {} 안에 반드시 연산자가 들어가 있어야 함
                               (= 3항연산자를 통해서 검색어가 NULL이나 ''인 경우를 [{}]안에서 쓸 수 없음)
  
                            b. 검색파이프라인의 [{조건1}, {조건2} ... ] 들은 JS변수에 객체배열의 값을 할당하여 쓸 수도 있음
  
                               ex) 이처럼 검색 조건식을 변수에 담아서 써도 아무 문제 없음 
                
                                   let 검색조건 = [
                                     {$search : {
                                       index : '사용할 인덱스 이름',
                                       text : { query : '검색어', path : '검색할 필드이름' }
                                     }},
                                     { $sort : { _id : 1 } },
                                     { $limit : 10 },
                                     { $project : { 제목 : 1, _id : 0 } }
                                   ] 
                  
                                   db.collection().aggregate(검색조건).toArray()
  
                            c. (2번의 특성을 이용해서) 조건 연산자들로 이뤄진 JS변수는 엄연히 '배열' 타입으로 이뤄져 있음
                                 -> 배열.push({ $연산자 : 조건내용 }); 을 통해 aggregate()의 parameter로 넣을 객체배열의 내용을 변환 가능
  

                  3. aggregate()에서 쓸 수 있는 대표적 연산자들 (= 찾아보면 더 있다 이런말..)
                 
                     1) $search : { index : '사용할 인덱스명', text : { query : '검색어', path : '검색할 field명' } }
                         : search index를 이용해서 주어진 조건들을 활용한 검색을 수행 
                           (= 사용하지 않으면, 검색어 없이 list를 가져오는 것과 같음)
                               -> (주의) 생각보다 쓰기전에 지켜야 할게 많은 녀석이니 주의가 필요
                                   a. 검색어를 기입하는 text 요소객체의 query 멤버변수에는 ''나 null은 허용되지 않음
                                   b. search는 쓸거면 무조건 파이프라인 배열의 1번째 요소객체가 되어야 함

 
                     2) $sort : { field명(= column명) : 숫자 }
                         : 검색 결과를 field명의 데이터를 기준으로 정렬 
                            -> 안 쓰면? 기본적으로 score 순으로 정렬됨
 
                                ex) { _id : 숫자}  -> 데이터들을 _id 순으로 정렬
                             
                     3) $limit : 숫자 
                         : 검색 결과의 데이터 수를 숫자 개수 만큼만 제한 (= cursor객체변수.limit(숫자)) 
                           
                           ex) { $limit : 10 } -> 검색결과 중에 맨 위의 10개 document만 가져올 수 있습니다. 
 
                     4) $skip : 숫자 
                         : 검색 결과의 데이터 수를 숫자 개수 만큼 지나친 위치에서 받아오기 시작함 (= cursor객체변수.skip(숫자)) 
                            -> 페이지네이션도 구현가능한 방법 중 하나
 
                           ex) { $skip : 10 } -> 검색결과 중에 맨 위의 10개는 버리고 11번째부터 document부터 가져와 줌 
 
                     5) $project : {필드명1 : 0 or 1, ... , 필드명n : 0 or 1}
                         : 데이터 검색 결과 중에 1번에 해당하는 필드명의 데이터들만 가져오라고 걸러줄 수 있음
                          
                           ex) {title : 1, content : 0}  -> 이러면 title은 보여줌, content는 숨김이라는 뜻


      # MongoDB와 웹서버 연결하기
         1. npm install mongodb@5 를 입력하여, mongodb 라이브러리 설치
         2. 보일러 플레이트를 server.js에 추가

            const { MongoClient } = require('mongodb')
   
            let db
            const url = 'mongodb사이트에 있던 님들의 DB 접속 URL'

            new MongoClient(url).connect().then((client)=>{

              console.log('DB연결성공')
              db = client.db('forum')   <- 간단히 설명하면 님들이 호스팅받은 mongodb에 접속하고 접속 결과를 db라는 변수에 저장

              app.listen(8080, () => {
                console.log('http://localhost:8080 에서 서버 실행중')
              })

            }).catch((err)=>{
                
              console.log(err)
            })

         3. url 변수에 'DB접속 URL'을 찾아넣자
             -> 만든 database의 connect 버튼을 누른 뒤, driver를 선택하면..
                "mongodb+srv://DB접속아이디:DB접속비번@cluster0.jea.mongodb.net/?retryWrites=true&w=majority"
                  -> 이런 느낌의 문자열이 나오는데, 이걸 찾아서 대입해주면 됨


      # MongoDB의 CRUD 사용법
         : client.db('프로젝트명').collection('컬렉션명').CRUD함수명({내용}) 형식으로 작성
            -> (주의) 기본적으로 MongoDB의 CRUD 함수는 Promise 객체를 활용하여 '비동기적'으로 작동하도록 작성된 함수라는 점을 명심... 
                      (= 따라서 MongoDB는 컨텍스트 제어를 위한 async, await를 항시 사용할 것을 권유함.. 그게 아니면 db요청 결과를 기다리지 않고, 그냥 진행함)
         
           1. (컬랙션명에 데이터를) 단일 입력(insertOne)
               : client.db('프로젝트명').collection('컬렉션명').insertOne( {칼럼명1 : '내용1'} , ... , {칼럼명2 : '내용2'} )

           2. (컬랙션명에 데이터를) 복수 개수 입력(insertMany)
               : client.db('프로젝트명').collection('컬렉션명').insertOne( {칼럼명1 : '내용1', 칼럼명2 : '내용2'} , ...  )

           3. 단일 데이터만 수정(updateOne)
               : client.db('프로젝트명').collection('컬렉션명').updateOne( {수정할 데이터 검색할 칼럼명 : '원래 내용'}, $예약어 {칼럼명1 : '수정할 내용1'} , ... , {칼럼명2 : '수정할 내용2'} } )

                 @ 예약어 리스트
                    1) set : 일반적인 데이터 덮어쓰기
                        
                        -> client.db('프로젝트명').collection('컬렉션명').updateOne( {수정할 데이터 검색할 칼럼명 : '원래 내용'}, { $set: {칼럼명1 : '수정할 내용1'} , ... , {칼럼명2 : '수정할 내용2'} } )

                    2) inc : 숫자로 적힌 해당 칼럼의 데이터를 적혀있는 양수/음수 만큼 더하거나 뺀 결과로 갱신해준다
                           
                        -> client.db('프로젝트명').collection('컬렉션명').updateOne( {수정할 데이터 검색할 칼럼명 : '원래 내용'}, { $inc: {칼럼명1 : 양수/음수} , ... , {칼럼명2 : 양수/음수} } )

                    3) mul : 숫자로 적힌 해당 칼럼의 데이터를 적혀있는 양수/음수 만큼 곱한 결과로 갱신해준다
                           
                        -> client.db('프로젝트명').collection('컬렉션명').updateOne( {수정할 데이터 검색할 칼럼명 : '원래 내용'}, { $mul: {칼럼명1 : 양수/음수} , ... , {칼럼명2 : 양수/음수} } )

                    4) unset : 해당 데이터를 찾은뒤 기존에 있던 필드를 제거함

                        -> client.db('프로젝트명').collection('컬렉션명').updateOne( {수정할 데이터 검색할 칼럼명 : '원래 내용'}, { $unset: 칼럼명1 , ... , 칼럼명2 } } )

           4. (검색에 해당되는) 복수 데이터들 일괄 수정(updateMany)
               : client.db('프로젝트명').collection('컬렉션명').updateMany( {수정할 데이터 검색할 칼럼명 : '원래 내용' or { $조건식 : 숫자 } }, $예약어 {칼럼명1 : '수정할 내용1'} , ... , {칼럼명2 : '수정할 내용2'} } )

                 @ 조건식
                    : > 5, <= 6 이런식으로 특정 연산조건에 맞는 데이터들만 골라서 검색할 떄 사용
                       -> {검색할 필드명 : { $조건식 : 숫자 } } 이런식으로 {}를 하나 더 만듦

                           1) $gt(greater than)        : '>' 초과를 의미
                           2) $gte(greater than equal) : '>=' 이상을 의미
                           3) $lt(greater than)        : '<' 미만을 의미   
                           4) $lte(greater than equal) : '<=' 이하를 의미   
                           5) $ne(not equal) : '!=' 어떤 수가 아님을 의미              

                              ex1) client.db('프로젝트명').collection('컬렉션명').updateMany( {수정할 데이터 검색할 칼럼명 : { $gt : 5 } }, { $set: {칼럼명1 : '수정할 내용1'} } )
                                    : 칼럼명이 5를 초과하는 모든 데이터의 칼럼명1의 값을 '수정할 내용1'로 수정해라

                              ex2) client.db('프로젝트명').collection('컬렉션명').updateMany( {수정할 데이터 검색할 칼럼명 : { $gte : 3 } }, { $inc: {칼럼명1 : -5} } )
                                    : 칼럼명이 3이 아닌 모든 데이터의 칼럼명1의 값을 -5해라

                 @ 예약어 {칼럼명 : { $예약어 : 내용 } }
                    : 말 그대로 특정한 개념을 의미하는 예약어로 용도에 맞게 사용
                       -> {검색할 필드명 : { $예약어 : 내용 } } 이런식으로 {}를 하나 더 만듦
                           -> 경우에 따라서는 {검색할 필드명 : { $예약어 : { $예약어 : 내용 } } } 이런식의 이중 예약어 {}도 사용 가능

                           1) $regex : 정규식과 연관된 연산자, 특정한 내용에 대해 정규식을 사용하여 검색함을 의미      

                              ex) client.db('프로젝트명').collection('컬렉션명').find( {title : {$regex : 요청.query.val} } );

                           2) $text   : text index와 연관된 연산자로, 해당 collection에서 필드를 text로 정렬한 index를 사용하겠다는 의미로 보통 $search와 같이 쓰임
                           3) $search : $text와 함께 쓰이는 연산자로, 특정한 내용에 대해 해당 collection에서 필드를 text로 정렬한 index를 사용해 검색함을 의미     

                              ex) client.db('프로젝트명').collection('컬렉션명').find( { $text : { $search: '안녕' } } ).
                                    : 해당 컬랙션명의 document 중 '안녕'이란 단어를 가지고 있는 녀석들을 데이터타입 text를 사용한 index를 사용해서 검색함을 의미

           5. 목록조회(find)
               : client.db('프로젝트명').collection('컬렉션명').find() 
                  -> 해당 프로젝트의 collection에 위치한 원하는 데이터 목록의 시작점이 위치한 DB의 커서 Cursor(DB 포인터 -> 메모리 주소)를 반환해 줌

                 @ Cursor 개념
                    : MongoDB에서 사용하는 데이터가 위치한 DB의 포인터에 해당되는 개념의 js객체로 find() 함수를 통한 쿼리의 결과값으로 반환됨
                       -> (중요) 그리고 이 Cursor 객체는 Cursor 객체를 parameter삼아 반환값으로 내놓는 메서드들을 가지고 있고, 메서드 chaining 사용가능함

                 @ find() 함수 기본 사용법
                    : find()안에 검색조건이 없으면, 해당 collection의 모든 데이터를 대상으로 함
                      (= find() 안에 칼럼명 : '내용' or '조건식' or '예약어'을 통해 검색조건을 내걸어서 원하는 데이터만 뽑는 쿼리를 작성도 가능함)
                          -> 예약어에는 index나 정규식들도 사용 가능

                       ex1) client.db('프로젝트명').collection('컬렉션명').find( { 칼럼명1 : '내용'}, ... , {칼럼명2 : '내용'} )
                       ex2) client.db('프로젝트명').collection('컬렉션명').find( { 칼럼명1 : { $조건식 : 숫자 } } , ... , { 칼럼명2 : { $조건식 : 숫자 } )

                 @ 대표적 Cursor 메서드들(cursor로 리턴되는 한 체이닝 가능)

                    1) cursor객체변수.toArray()
                        : MongoDB내부에서 제공하는 'Cursor객체(= db 포인터) -> JS object배열'로 변환시켜 실체화된 데이터로 다룰 수 있게 하는 메서드
                           -> (중요) 일단 .toArray()를 통해 'cursor객체변수'의 내용 -> '배열' 로 변환하였으면, 그 원본인 커서를 가공한뒤 toArray() 함수로 사용할 수 없음
                               -> toArray() 메서드를 사용하여 어떤 커서변수를 배열로 변환할 때, 내부적으로 원본 커서변수를 사용하기에 그 원본 커서변수는 이미 사용 중이므로 다른 메서드를 호출할 수 없음
                                  (= cursor객체변수와 toArray()를 통한 document의 js객체배열은 일종의 의존성 관계에 놓여있다고 보면 됨)

                                  ex) (중요!) result가 쓰려는 커서변수 original은 이미 array가 사용 중인 상황이라, 새롭게 초기화하는게 불가능함
                                       -> result는 original과 같은 내용의 crud 함수를 다시 실행해서 아직 toArray()를 통해 내부적으로 커서변수가 존재하지 않는 새로운 커서변수를 사용해야 함
                                  
                                      let original = await db.collection('post').find();
   
                                      let array = await original.toArray();
                                      let result = await original.skip( (요청.params.page - 1) * 5 ).limit(5).toArray();

                    2) cursor객체변수.count()
                        : 해당 cursor가 가르키는 위치에 존재하는 데이터의 수를 집계함

                    3) cursor객체변수.skip(숫자)
                        : 해당 cursor가 가르키는 위치에 존재하는 1번째 데이터를 기준으로 몇 개의 데이터를 데이터 목록에서 뺌
                           -> (주의) 너무 큰 수를 적으면, 성능에 지장 생김

                    4) cursor객체변수.limit(숫자)
                        : 해당 cursor가 가르키는 위치에 존재하는 데이터를 기준으로 몇 개의 데이터만 데이터 목록에 반영 
                           -> cursor는 데이터가 위치한 곳의 시작 위치를 알려줄 뿐이라, 관계형 db처럼 실제로 뽑아온 데이터를 바탕으로 재가공에 재가공 체이닝을 거는 기능을 약할 수 밖에 없음.. 대충 거기 기준 몇개 거르고 몇개 뽑아와 정도...
                              (= limit와 sort를 체이닝 해봐야 관계형DB처럼 연쇄가공을 통한 원하는 데이터를 조작하듯 뽑는게 많이 힘듦... limit가 먼저오면 sort가 씹힌다)

                    5) cursor객체변수.sort( {기준칼럼 : + or -} )
                        : 해당 cursor가 가르키는 위치에 존재하는 데이터목록을 정렬값에 따라 오름차순 or 내림차순하여 목록에 반영

                    6) cursor객체변수.next()
                        : 현재 cursor의 값을 기준으로 다음 데이터의 위치를 반환

                    7) cursor객체변수.explain("executionStats")
                        : 현재 cursor의 값이 도출되기까지의 성능과 관련된 통계에 대한 데이터를 반환
                            -> 참고내용 (예시는 index 개념 참고)
                               - totalDocsExamined: 참조된 document 횟수
                               - executionStages  : 쿼리 수행 상세 정보 객체
                                  1) stage : 어떤식으로 작업을 했는가?
                                      -> inputStage가 executionStages의 멤버객체 X
                                           A. TEXT_MATCH : TEXT 일치여부 기준으로 스캔
                                           B. COLLSCAN   : index를 사용X, 콜랙션의 데이터 전체 스캔(Collection Scan)
           
                                      -> inputStage가 executionStages의 멤버객체로 생성
                                           A. SORT : find() 이후 SORT 함수를 사용하였으나, 해당 collection의 모든 필드가 정렬기준이 마련되지 않아 일부만 index가 적용된 경우
                                               -> inputStage 멤버객체의 stage멤버변수는 "SORT_KEY_GENERATOR"라는 상태값을 가지고, 부분적으로 적용된 index가 있다면, 하위 indexName을 가지는 inputStage 멤버객체가 존재함
                                           B. FETCH : find() 이후 SORT 함수를 사용하고, 해당 collection의 모든 필드가 적용된 compound index가 존재하여 사용 하는 경우 
                                               -> inputStage 멤버객체의 stage멤버변수는 "IXSCAN"라는 상태값을 가지며, indexName라는 멤버변수를 가짐 
           
                                  2) inputStage : stage에서 선택한 방식의 세부사항을 적음

                 @ (응용) 만약..? 페이지네이션 같이 특정 부분에 존재하는 데이터들을 몇 개만 가져오고 싶으면?
                    : find() 함수를 사용하여 뽑은 목록값에 추가적인 함수 chaining을 통해 추가적 데이터 목록의 통제가 가능
                      (해당 db위치를 기준으로 ( [생략가능] '숫자'만큼의 데이터들은 건너뛰고) '숫자'만큼의 데이터만 가져옴)
                        -> cursor객체변수.[skip(숫자)].limit(숫자).toArray();


           6. 개별조회(findOne)
               : client.db('프로젝트명').collection('컬렉션명').findOne( {칼럼명 : '내용'} );
                  -> 칼럼명이 '내용'에 들어맞는 어떤 1가지의 데이터만 뽑음
                     (= (중요) 1개의 데이터를 뽑는 것이기에, toArray()는 사용할 수 없음)

                 @ (주의) 데이터의 고유 id인 _id를 찾아서 검색하고 싶은 경우
                     1) const { ObjectId } = require('mongodb') 코드를 반드시 추가해야 함
                        -> 정확히는 ID기반 검색시 생성된 JS에서 이 ID정보를 인식하고 DB에 검색 명령 내릴때 전달가능하게 하는 JS객체에 해당하는 ObjectId 변수가 모듈의 사용영역에 포함되어 있어야함 
         
                     2) 개별검색 항목에 입력하는 id번호는 new ObjectId(id번호) 형식으로 내용을 기입
                     
                        ex1) URL 파러미터 사용시
                           
                            app.get('/detail/:id', async (요청, 응답) => {
                               let result = await db.collection('post').findOne({_id : new ObjectId(요청.params.id)});
                               응답.render('detail.ejs', { 상세글 : result })
                            });

                        ex2) QueryString 사용시
                           
                            app.get('/detail', async (요청, 응답) => {
                               let result = await db.collection('post').findOne({_id : new ObjectId(요청.query.id)});
                               응답.render('detail.ejs', { 상세글 : result })
                            });

                 @ (중요) BSON
                     : JSON과 유사하지만 추가적인 데이터 타입과 기능을 제공하여 MongoDB와 같은 NoSQL 데이터베이스에서 사용

                 @ (중요) ObjectId 개념
                     : BSON(Binary JSON) 형식으로 RDBMS에서 Primary Key와 같은 고유한 키 역할을 수행하기 위해 만들어진 특별한 유형의 데이터 타입
                        -> mongoDB db에서 document에 저장된 _id라는 field를 보면 저장된 내용을 확인 가능하며, 직접적인 BSON 형식으로 저장되어 있진 않고 new ObjectID('BSON 제조용 parameter문자열')라는 JS생성자 형식으로 저장됨

                           - new ObjectID('BSON 제조용 parameter문자열')
                               : 파라미터로 전달된 문자열에 따라 BSON 형식의 ObjectID를 생성하는 JavaScript의 생성자 함수
                                 
                                 ex) new ObjectID('5b7d297cc718bc33212aa94)
   
                           - 'BSON 제조용 parameter문자열'의 구조
                               : 총 12byte 16진수로 구성.. 보통 따로 저장하지 않으면 생성규칙에 맞춰 자동생성되며 그 소스는 초단위의 생성시간도 포함되어 있기에.. 자동생성시 고유성을 확보가능하게 설계됨
                                 (= 총 12byte로 구성된 BSON 제조용 parameter문자열 내용을 파싱하면, ObjectID의 내용을 알 수 있음)                     
                                    -> Timestamp(4바이트)          : Unix epoch이후 ObjectID가 생성된 시간(초)을 나타냄 (= 문서 순서를 생성순으로 유지가능)
                                    -> Machine identifier(3바이트) : ObjectID를 생성한 컴퓨터의 기계 식별자
                                    -> Process identifier(2바이트) : ObjectID를 생성한 프로세스의 식별자
                                    -> Counter(3바이트)            : 같은 프로세스에서 동시에 생성된 ObjectID를 구분하기 위한 카운터 값

                           - ObjectId객체.equals(ObjectId객체)
                              : server.js에서 JS객체인 ObjectId들이 같은지를 확인할 때, 그들의 힙영역의 포인터가 같은지 여부를 비교하기 위해 사용하는 mongoDB 라이브러리의 함수 (==, === 필요X)
                                 -> (주의) 사용하기 전에 ObjectId라는 객체 타입의 정의가 필요한 관계로... 이를 정의한 mongodb 라이브러리를 import하지 않은 상태에서 사용시 에러가 발생함
                                    (= ejs화면 파일에서 ObjectId라는 무턱대고 사용하면 오류가 발생하는 대부분의 원인을 차지)

                           - (중요!) ObjectId 형식 사용시 주의점
                              1) mongoDB에 CRUD 함수 수행시, server.js에서 해당 형식의 값을 전달하기 위해서는 new ObjectId('BSON 형식 문자열')로 입력해야, DB에서 해당 값을 적합하게 인지하여 기록하거나 쿼리에 파라미터로 사용함

                              2) 'BSON 제조용 parameter문자열'로 들어갈 byte크기가 12byte를 넘거나, 파싱할 수 없는 형식으로 입력되면 에러가 유발됨
                                 (= new ObjectId('BSON 형식 문자열')은 new ObjectId(new ObjectId('BSON 형식 문자열')) 이런 식으로 들어갈 수 없음)
 
                              3) 'BSON 제조용 parameter문자열'이 곧 ObjectID의 내용임

                              4) (중요!) server.js에서 new ObjectId 형식의 값은 mongodb 라이브러리에서 정의한 ObjectId라는 형식의 js객체로서 인식됨
                                  -> server.js에서 new ObjectId 형식의 값 비교를 위해서, ObjectId객체.equals(ObjectId객체) 함수를 사용
                                      -> 단! mongodb 라이브러리의 import는 반드시 해야 ObjectId 타입의 메서드인 equals() 함수 사용 가능
                                         (= ejs화면 파일에서 equals를 무턱대고 사용하면 오류가 발생하는 대부분의 원인을 차지)

                              5) (중요) ejs 확장자의 화면에서 ObjectId 형식의 값을 출력할 시? 
                                 (= 어떤 영역에 있냐에 따라 형변환 규칙이 달라지고, 이에 따라 출력이 달라짐)
                                    -> 서버 측 템플릿 영역
                                        : JS의 자동 형변환 규칙을 ㅈ까고, 템플릿 엔진은 템플릿 코드를 그대로 출력하거나 서버 측에서 제공된 데이터를 문자열로 변환하여 템플릿에 삽입
                                          (= JS객체화 된 ObjectId 형식의 변수를 문자열로 출력하고 싶으면, 명시적으로 toString() 함수를 적용해줘야 함) 

                                    -> 화면 측 script 영역
                                        : JS의 자동 형변환 규칙에 따라서, 자동으로 toString() 함수를 적용하여, BSON 형식 문자열 그 자체로 출력
                                          (= ejs 확장자의 화면측의 영역에서는 ObjectId 형식의 값 비교는 늘 하던데로 ==, === 와 같은 연산자를 사용하면 됨)
                              
           7. (중요) 만들어진 search index server.js에서 활용하는 코드
              : client.db('프로젝트명').collection('컬렉션명').aggregate()
                 -> .find()와 유사.. BUT! ()안에 여러 조건식을 [{조건1}, {조건2} ... ] 형식으로 적용을 원할 때 사용

                @ (중요!) AggregationCursor 개념 ( <-> cursor)
                   : aggregate() 함수가 반환하는 return값으로 cursor와는 호환되지 않는 고유한 타입의 객체
                     (= 다른 CRUD 함수들이 체이닝할 수 있는 count() 같은 몇몇 함수들이 호환되지 않음!!)
                         -> count 같은 경우는 toArray()를 통해 객체배열로 변환한 뒤, length 멤버 변수를 통해 구함
                     
                @ 검색파이프라인
                   : aggregate() 안의 [{조건1}, {조건2} ... ] 으로 들어가는 객체배열
                      -> 검색파이프라인 특성
                          a. 검색파이프라인 내부에 존재하는 연산자 조건을 담은 객체 {} 안에 반드시 연산자가 들어가 있어야 함
                             (= 3항연산자를 통해서 검색어가 NULL이나 ''인 경우를 [{}]안에서 쓸 수 없음)

                          b. 검색파이프라인의 [{조건1}, {조건2} ... ] 들은 JS변수에 객체배열의 값을 할당하여 쓸 수도 있음

                             ex) 이처럼 검색 조건식을 변수에 담아서 써도 아무 문제 없음 
              
                                 let 검색조건 = [
                                   {$search : {
                                     index : '사용할 인덱스 이름',
                                     text : { query : '검색어', path : '검색할 필드이름' }
                                   }},
                                   { $sort : { _id : 1 } },
                                   { $limit : 10 },
                                   { $project : { 제목 : 1, _id : 0 } }
                                 ] 
                
                                 db.collection().aggregate(검색조건).toArray()

                          c. (2번의 특성을 이용해서) 조건 연산자들로 이뤄진 JS변수는 엄연히 '배열' 타입으로 이뤄져 있음
                               -> 배열.push({ $연산자 : 조건내용 }); 을 통해 aggregate()의 parameter로 넣을 객체배열의 내용을 변환 가능


                @ aggregate()에서 쓸 수 있는 대표적 연산자들 (= 찾아보면 더 있다 이런말..)
                
                   1) $search : { index : '사용할 인덱스명', text : { query : '검색어', path : '검색할 field명' } }
                       : search index를 이용해서 주어진 조건들을 활용한 검색을 수행 
                         (= 사용하지 않으면, 검색어 없이 list를 가져오는 것과 같음)
                             -> (주의) 생각보다 쓰기전에 지켜야 할게 많은 녀석이니 주의가 필요
                                 a. 검색어를 기입하는 text 요소객체의 query 멤버변수에는 ''나 null은 허용되지 않음
                                 b. search는 쓸거면 무조건 파이프라인 배열의 1번째 요소객체가 되어야 함

                   2) $sort : { field명(= column명) : 숫자 }
                       : 검색 결과를 field명의 데이터를 기준으로 정렬 
                          -> 안 쓰면? 기본적으로 score 순으로 정렬됨

                              ex) { _id : 숫자}  -> 데이터들을 _id 순으로 정렬
                           
                   3) $limit : 숫자 
                       : 검색 결과의 데이터 수를 숫자 개수 만큼만 제한 (= cursor객체변수.limit(숫자)) 
                         
                         ex) { $limit : 10 } -> 검색결과 중에 맨 위의 10개 document만 가져올 수 있습니다. 

                   4) $skip : 숫자 
                       : 검색 결과의 데이터 수를 숫자 개수 만큼 지나친 위치에서 받아오기 시작함 (= cursor객체변수.skip(숫자)) 
                          -> 페이지네이션도 구현가능한 방법 중 하나

                         ex) { $skip : 10 } -> 검색결과 중에 맨 위의 10개는 버리고 11번째부터 document부터 가져와 줌 

                            -> 당연히 { $skip : 5 } 이거 연산자도 쓸 수 있습니다. 그래서 이런거 쓰면 

                   5) $project : {필드명1 : 0 or 1, ... , 필드명n : 0 or 1}
                       : 데이터 검색 결과 중에 1번에 해당하는 필드명의 데이터들만 가져오라고 걸러줄 수 있음
                        
                         ex) {title : 1, content : 0}  -> 이러면 title은 보여줌, content는 숨김이라는 뜻


      # express HTTP API와 연계된 MongoDB의 CRUD 작성법
         : express 라이브러리의 HTTP 메서드에 해당하는 함수에 parameter로 들어갈 URL과 그에 대응하는 CRUD를 담은 무명함수를 적어서 API로 완성함

           ex) app.get('/news', ()=>{
                 db.collection('컬렉션명').insertOne({title : '어쩌구'})         // MongoDB의 CRUD 함수
               })

               app.get('/list', async (요청, 응답) => {
                 let result = await db.collection('컬렉션명').find().toArray()   // MongoDB의 CRUD는 비동기로 작동하는 코드라는 점도 잊지마라!
                 응답.send(result[0].title)
               })

      # MongoDB에서 가져온 데이터를 HTML에 뿌리려면 어떻게 해야하나?
         : JS의 템플릿 엔진과 관련된 라이브러리를 통해서 뿌리면 됨... 템플릿 엔진 관련 문서 참조
           (= 그러니까 JSP에서 DB의 데이터 뿌릴 때, 쓰던 방식과 유사하다 생각하면 됨)