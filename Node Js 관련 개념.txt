- 서버(server)
   : 누가 어떤 데이터를 '요청'하면 보내주는(= '응답') 역할을 수행하는 프로그램 
      -> 그 프로그램을 수행하는 실체가 물리적 컴퓨터일수도 있고, 논리적으로 분리된 가상 컴퓨터일수도 있음
         (비슷한 코드를 짜다보니 효과적인 중복방지를 위한 패턴으로 인해, 분리와 조건문 다형성을 활용한 패턴을 적극활용하는 경우가 많을 뿐)

    # 웹서버
       : 누가 어떤 홈페이지 도메인(URL)으로 접속하면 거기맞는 html을 보내주는 서버
          -> (주의) 클라이언트가 화면에서 db조작을 해서 CRUD 명령어를 실행해도, 화면이 그에 맞춰 반응하려면, 반응형 동작을 비동기적으로 지원해주는 프레임워크 쓰지 않는이상, 새로고침없이 화면 자체에서 그 데이터를 실시간으로 반영하진 않음

    # 포트(port)
       : 내 컴퓨터의 ip가 일종의 국가면, 포트는 항구와 같은 의미로.. 이 포트라는 단위를 기준으로 컴퓨터는 여러 컴퓨터 및 어플리케이션들과의 통신을 구분하여 주고 받을 수 있도록 할당받음 
          -> BUT! 기본적으로 유명한 번호의 포트는 컴퓨터에서 이미 사용하거나, 특정 기능이나 앱이 사용하도록 할당되는 경우가 있는데, 이런건 따로 건드는일 없도록 해 함


- HTTP 메서드
   : HTTP를 통해 서버에 데이터를 어떻게 해달라고 요청하는 동사(Verb)로서의 의미를 가진방식(메서드)으로서 크게 5가지로 구분
     -> 이를 기반으로 어떤 종류의 데이터(Resource)를 작업해달랄지에 대해서는, URI 통해 전달함으로서 서버는 API의 종류를 구분함 
        (널리 사용되는건 get, post2가지)

        1. GET
            : 서버에게 데이터를 달라고 요청할 때 사용 (사용자가 보낸 URL 파라미터가 공개됨)

        2. POST
            : 서버에게 데이터를 보내서, 이를 가공하여 무언가를 요청하기까지 하는 광범위한 작업을 요청시 사용 
              (여기서부터는 사용자가 보낸 데이터 UTL에 보이지 않음)

        3. PATCH
            : 서버에게 이미 존재하는 데이터의 일부를 수정할 때 사용
        
        4. PUT
            : 서버에게 이미 존재하는 데이터면 이를 통째로 바꾸도록, 없으면 추가하도록 할 때 사용

        5. DELETE
            : 서버에게 데이터를 삭제요청시에 사용


- 미들웨어(middleware)
   : 웹서버의 API가 클라이언트의 요청으로 호출될 시, 응답되기 전에 실행되는 함수를 큰 틀에서 통칭하여 의미
      ex) API를 실행하기 전에, 현재 요청한 유저가 login을 한 상태인지 API를 응답하기 전에 실행하는 코드 및 함수 내용

    # next()
       : 미들웨어 함수의 3번째 파라미터로 들어가는 콜백함수로서, 미드웨어의 실행이 완료되었으니, 본 API를 실행시키라는 내용을 가지고 있음
         (= 미들웨어의 2번째 파라미터인 API 응답 객체가 실행되면, 이 next() 함수를 실행할 방법이 사라져 버리니.. 본 API코드는 작동하지 않음) 

         @ (주의) next()는 제너레이션 함수 객체에서 사용되는 함수이긴 하지만, express 라이브러리의 해당 미들웨어 함수 설계와는 영 관계가 없음

    # 미들웨어(middleware)를 구현하는 방법들
    
       1) API의 내용을 작성할 떄, 응답 로직코드의 바로 위에 작성

          ex) express().http메서드명('/어쩌구', (요청, 응답)=>{ 미들웨어 내용 작성 + API내용 });

          ex) function 함수(요청){
                if(요청.user){ 로그인했군~ }
              }
          
              express().http메서드명('/어쩌구', (요청, 응답)=>{ 함수(요청) + API내용 });


      [express 프레임워크를 사용한다면?]
        : 정확한 내용은 express 영역에서도 설명함

       2) express().http메서드명('/어쩌구', 미드웨어 함수명 or 무명 미드웨어함수, (요청, 응답)=>{ API내용 });
           : express().http메서드명()을 사용한 API의 parameter를 작성할 때, 특정 함수내용을 미들웨어로서 작동하게 하고 싶을 경우
              -> express().http메서드명()의 parameter로 'url' , 무명콜백함수(요청, 응답) 사이에 미들웨어로 쓸 함수명이나 무명함수를 작성함
                 (= 함수명 or 무명함수는 자동으로 API 요청받고 응답코드 실행하기 전 사이시간에 실행됨)
   
                  ex) function 함수(요청, 응답){             <- 1개의 parameter만 들어갔으니, 1번째 parameter는 API 요청 관련 정보 객체를 가진다
                        if(요청.user){ 
                          로그인했군~ 
                        } else {
                          응답.send('로그인안했는데요?')      <- 작동되는 순간 본 API코드는 실행X (= API {} 탈출), 그래서 조건문으로 분기 작성
                        }
                      }
                  
                      express().http메서드명('/어쩌구', 함수, (요청, 응답)=>{ API내용 });
               
                  ex) express().http메서드명('/어쩌구', (요청, 응답, next() ) => { 미들웨어 내용 } , (요청, 응답)=>{ API내용 });
   
   
               @ express().http메서드명()을 사용한 미들웨어 설정시 주의사항
   
                  a. (중요!) 미들웨어 자리에 위치한 함수의 parameter는 위치에 따라 자동으로 용도가 결정됨
                  
                    - 1번째 paramter
                       : API 요청 관련 정보 객체
                         (요청.body, 요청.query, 요청.user 다 사용가능)
                         
                    - 2번째 paramter
                       : API 응답 관련 정보 객체 
                         (= 응답.redirect, 응답.send, 응답.render 다 사용 가능)
                            -> BUT! 응답객체를 미드웨어 안에서 작성하고, 이걸 호출하게 된다면, 본 API코드까지 넘어가지 않음
                               (= 미드웨어의 응답객체 코드 = 함수 {} 안에서의 return 코드)
                           
                    - 3번째 paramter
                       : 콜백으로 쓸 미들웨어가 끝났음을 알리고 본 API의 응답코드로 넘어가게 해주는 next() 함수
     
                  b. 미들웨어를 여러개 사용하고 싶으면, [함수1, 함수2, 함수3] 이렇게 array 형태로 넣는거도 가능함
     
                      ex) express().http메서드명('/어쩌구', [함수1, 함수2, 함수3] , (요청, 응답)=>{ API내용 });

       3) express().use( (생략가능) URL명, 미드웨어 함수명 or 무명 미드웨어함수)
           : 특정 함수내용을 미들웨어로서 그 밑에 위치한 모든 express().http메서드명()을 사용한 API에서 작동하게 하고 싶을 경우 사용

              @ express().use()을 사용한 미들웨어 통합 설정시 주의사항

                 a. 해당 코드 하단의 모든 express().http메서드명()을 사용한 API들은 use()안의 미드웨어 함수 내용을 미드웨어로서 실행함
                    (= (중요!) 위치에 따라 적용범위가 달라진다 ...이 말씀)

                     ex) express().use(checkLogin)     <- 해당 코드 하단의 모든 express().http메서드명()을 사용한 API들은 미들웨어로 checkLogin을 사용...

                 b. use() 함수의 1번째 paramter에 'url명'을 적으면, 해당 url명으로 시작되는 API만 골라서 미들웨어를 적용해줌 

                     ex) express().use('/어쩌구', checkLogin)   <- 해당 코드 하단의 express().http메서드명() 중 URL이 '/어쩌구'로 시작되는 API들은 미들웨어로 checkLogin을 사용...


- RESTful(Representational State Transfer) API
   : 웹서버에서 URI + HTTP 메서드를 통해, 사용자와 운영자 모두에게 좋은 방식의 웹서버 API를 설계(= 작명)하는 6가지 방법론으로 이해
     (= 그냥 method, URL만 잘 기입해두면 관습적으로 REST하다고 함... )

      1. 일관적인 인터페이스(Uniform Interface)
          : 여러 URL과 method는 전체적인 개념에 일관성이 있어야 함
             - 하나의 URL로는 하나의 데이터를 가져오게 디자인하는게 좋고 
             - 간결하고 예측가능하게 URL과 method를 만드는게 사용자, 운영자 모두에게 좋음 
      
      2. Client-server 역할 구분 
          : 사용자는 사용자고! 서버는 서버다! 
            (= 사용자에게 서버가 할 역할을 맡기거나 DB를 직접 입출력하게 하는 기능을 오픈하면 안됨!)
      
      3. 무상태(Stateless)성 유지
          : 모든 요청들은 서로 의존성이 있는거 보단, 각각 독립적으로 처리되도록 API는 설계되어야 함
      
      4. 캐싱가능함(Cacheable)
          : 웹서버가 사용자들에게 보내는 자료들은 캐싱이 가능해야 좋음
             -> 자주 받는 자료들은 브라우저에서 하드에 저장해놓고 쓸 수 있게 하기에, 사용자나 서버나 트래픽이나 시간 낭비가 없음
      
      5. 계층화된 구조(Layered System)
          : 서버기능을 만들 때 레이어를 걸쳐서 코드가 실행되도록 만드는게, 프로그램의 코드 실행의 역할과 책임을 구분하기 유리함
      
      6. 실행가능한 코드(Code on demand)
          : 서버는 실행가능한 코드를 보냄으로서, 시스템에 유연성과 확장성을 제공할 수 있음

    # (참고) 그 외 API 설계시 도움되는 내용
       1. 단어들을 동사보다는 명사 위주로 구성함 
           -> 동사적 의미는 HTTP 메서드에게 맡기도록 하자

       2. 띄어쓰기는 언더바(_) 말고, 대시(-)를 사용하는게 직관적임
       3. 파일 확장자 쓰지 말기 (.html 이런거)
       4. 하위 문서들을 뜻할 땐 / 기호를 사용함 (하위폴더같은 느낌)

    # (참고) 웹서버 API 로직 작성시, 서버 API를 거치게 될 때 validation처리나 예외처리 코드를 짜는 방법론
        -> 물론 가능한 웹페이지에서 입력을 받기 전에 이를 거를 수 있게하는 로직이 들어가는게 중요함

           1. 필수적으로 들어가야 하는 데이터가 누락되거나, 적절하지 않게 들어갔다??
               : 조건문을 사용하여, 요청시 전달된 데이터 중 필요 데이터가 없거나 입력X 시를 기준으로 처리법을 나누기
                  -> or validation 라이브러리를 쓰는 것도 방법...  
                  
                     ex) express-validator, vinejs, validator 
    
           2. 어떤 코드 영역을 실행시 잠재적으로 에러가 나올수도 있는 코드가 예상된다??
               : try, catch(e) 구문을 통해, 에러가 예상되는 코드를 영역으로 묶은뒤 거기서 일어나는 에러를 처리할 수 있는 catch영역 코드를 작성하기


- (중요) 웹페이지 -> 웹서버로 데이터를 전송하는 방식
  1. URL의 일부로 데이터를 포함해서 href 속성값으로 url을 설정하여 API를 호출하여 서버로 무식하게 보냄..
      : 말 그대로 브라우저의 주소창에 해당하는 window.location.href의 속성값을 변경하는 방법으로 웹서버에 무식하게 호출을 보냄

       # window.location.href
          : window객체의 브라우저의 요소를 구성하는 객체로, a태그의 href속성의 그것과 같이 현재 위치하는 url 주소를 띄어줌
           
            @ href 특징
             - a태그를 클릭시 일어나는 그것도 이와 같은 녀석
             - 이벤트 리스너를 통해 변경도 가능함
             - (중요) [단점1] 이를 통해서는 GET방식의 호출 밖에 할 수 없음
             - (중요) [단점2] 반드시 새로고침이 일어나는 방식임
             

       # 응용 & 연계에 필요지식 
          : 여기 내용들을 통해, 웹페이지에서 API를 호출하는 url에 데이터를 기입하는 과정에 도움이 될 수 있음

          1) eventlistener(이벤트 리스너)
              : js가 HTML요소를 접근하는데 사용하는 DOM 객체에서 어떤 형식의 이벤트(클릭, 드래그 등등)가 발생할 경우, 어떻게 처리하라는 내용을 가지고 처리해주는 js객체인 함수
                (= 해당 HTML요소에 이벤트가 발생하면, 그에 대응하는 이벤트리스너 함수로 연결해줘 이벤트 내용을 실행함)
                    -> DOM요소.addEventListener('이벤트종류', function(e){ 내용 }); 과 같은 형식으로 어떤 HTML객체에 이벤트가 발생했을때 어떤식으로 반응하라고 코드를 짜서, 원하는 웹페이지 기능을 만들 수 있음
          
          2) e(이벤트 객체)
              : 이벤트를 발생시킨 HTML요소와 발생한 이벤트 그 자체에 대한 정보나 함수를 가지는 js객체로.. 정말 다양한 내용들을 담고 있어 이벤트 내용을 짜는데 유용함
                (= 이를 쓰기 위해서는 설정한 이벤트의 콜백함수인 이벤트리스너 함수의 1번쨰 파라미터를 적어놔야 하며, 주로 e라고 적음

                ex) document.querySelectorAll('.delete2')[<%= i %>].addEventListener('click', function(e){ e.이벤트객체명으로 원하는 멤버명을 찾아서 사용   });

          3) HTML dataset 속성
             : HTML요소에 `data-dataset명="내용"` 과 같은 형식으로 HTML 속성을 입력하고 난 뒤, 해당 HTML요소에 이벤트가 발생한다면, 그 이벤트에 반응하는 이벤트리스너의 이벤트객체 e를 통해 해당 속성값들을 바로 참고할수 있도록 하기 위한 속성
                -> 이벤트함수의 콜백함수 parameter인 이벤트리스너 함수 스코프에서 e.target.dataset.dataset명 으로 값을 불러와서 사용가능함

                   ex) <span class="delete2" data-id="<%= 글목록[i]._id %>" data-row="<%= i %>">🗑️</span>

                       document.querySelectorAll('.delete2')[<%= i %>].addEventListener('click', function(e){
                          fetch('/delete?id=' + e.target.dataset.id, { method : 'DELETE' })
                       });

       #  URL의 일부로 보내는 데이터 형식
          1) URL 파라미터
              : NodeJS를 사용한 서버 API 설정을 통해 URL에서 파라미터로 보낸 정보의 위치를 서버가 찾고 판별할 수 있는 형식을 API의 URL에 적어서, 사용자 측에서 보낸 API 요청에 응답할 때 URL에서 데이터를 특정 변수명으로 대입해서 쓰는 방식 
                 -> 그렇게 받은 정보는 API {} 내부에서 '요청parameter명.params'로 접근하여 해당 URL파라미터들을 모아 기록한 객체에 쓸 수 있음
                    (= '요청parameter명.params' 형식으로 사용이 가능한 이유는 얘도 queryString이나 qs라는 NodeJs의 라이브러리를 사용하기 떄문)
                       
                     ex) [웹페이지에서 API를 호출시 정해진 부분에 URL 파라미터 기입]
                              
                          document.querySelectorAll('.list')[<%= i %>].addEventListener('click', function(e){
                             fetch('/detail/ + e.target.dataset.id, { method : 'GET' })
                          });
                        
                         [server.js에서는 url 파라미터를 ':ID명'으로 기입 후, 보낸 내용들을 '요청.params'를 통해 읽을수 있음]
                     
                          app.get('/detail/:id', async (요청, 응답) => {
                             let result = await db.collection('post').findOne({_id : new ObjectId(요청.params.id)});    <-  요청.params 구성은 [ {para1 : para1값} , {para2 : para2값} ] 이고, 요청.query.id 이런식으로 접근 가능
                             응답.render('detail.ejs', { 상세글 : result })
                          });

               @ 장점
                  1. 그나마 보내는 데이터가 어떤 칼럼에서 나오는지를 가리기에 보안적인 면에서 나을수는 있음

               @ 단점
                  1. 약간이나마 서버 API의 URL에 설정이 필요하다는 단점 존재
                  2. POST 방식을 쓰면 그나마 낫지만, 기본적으로 URL에 데이터를 포함해서 보내기에 보안이 씹망

          2) queryString
              : 서버 API 도메인주소에 파라미터 관련 아무런 설정이 필요없이, 웹페이지에서 fetch API나 axios 등을 사용하여 URL에 대놓고, '도메인?데이터이름=데이터값&...' 이런식으로 데이터를 전송하는 방식... 
                 -> 그렇게 받은 정보는 웹서버 API {} 내부에서 '요청parameter명.query'로 접근하여 해당 URL파라미터들을 모아 기록한 JS객체 형식으로 접근가능
                    (= '요청parameter명.query' 형식으로 사용이 가능한 이유는 얘도 queryString이나 qs라는 NodeJs의 라이브러리를 사용하기 떄문)

                 ex) [웹페이지 event설정을 통한 fetch API에 쿼리스트링 기입]
                       
                      document.querySelectorAll('.list')[<%= i %>].addEventListener('click', function(e){
                         fetch('/detail?id=' + e.target.dataset.id, { method : 'GET' })
                      });
                 
                     [server.js에서는 아무런 url 파라미터 같은걸 안 써줘도 보낸 내용들을 '요청.query'를 통해 읽을수 있음]
                     
                      app.post('/detail', async (요청, 응답)=>{
                         await db.collection('post').deleteOne( { _id : new ObjectId(요청.query.id) } );    <-  요청.query의 구성은 [ {id : id값} , {name : name값} ] 이고, 요청.query.id 이런식으로 접근 가능
                         응답.render('detail.ejs', { 상세글 : result })
                      });

               @ 장점
                  : 그냥 사용이 ㅈㄴ 간편하며, 어떤 라이브러리나 설정이 필요없이 그냥 기본적으로 지원됨

               @ 단점
                  : POST 방식을 쓰면 그나마 낫지만, 기본적으로 URL에 데이터를 포함해서 보내기에 보안이 씹망
                     -> 그런 중대한 문제가 있어.. express 라이브러리에서 url인코딩 미드웨어(하단 express의 API목록 참고)를 쓸 때.. 그 옵션으로 보안성 확정 여부를 묻는게 존재함
                        (= 기본 queryString의 보안문제를 해결한 qs 라이브러리가 존재함.. npm install qs로 인스톨 가능)

  2. HTML의 FORM태그를 사용해서 전송하는 방법
      : FORM태그의 action 속성에 url을 적고, method 속성에 HTTP 메서드를 적어서 웹서버에 API를 요청함

       # 장점
          : HTML레벨에서 지원하는 방식이기에, 이벤트 동작은 신경 안 써도 되고 상대적으로 화면에서 할게 적은 편

       # 단점
          1. 웹서버에 내용을 전송하면, 새로고침을 하게 됨
          2. 비동기적인 동작이 불가능함 = 전송이 끝날 때까진 아무것도 조작이 불가능함 = 소비자 경험이 ㅈ됨
          3. GET, POST 밖에 HTTP 메서드를 쓸수가 없음
 
             @ NodeJs 환경에서 FORM 태그를 통한 전송에 PUT이나 DELETE 메서드를 쓰고 싶은 경우
                1) AJAX 전송을 쓴다
                2) method를 강제로 변경해주는 라이브러리를 사용
                   
                   ex) method-override
                        1) npm install method-override 터미널에 입력
                        2) server.js에 보일러 플레이트 코드 입력
         
                           const methodOverride = require('method-override')
                           app.use(methodOverride('_method')) 
             
                        3) form 태그에서 url을 날릴 때, '?_method=HTTP메서드' 를 붙이면 다른 HTTP 메서드로 전송 가능하게 덮어써 줌
         
                           ex) <form action="/edit?_method=PUT" method="POST"> </form> 

  3. Ajax(Asynchronous JavaScript and XML)를 사용
      : JavaScript의 함수(fetch)나 라이브러리(express)의 함수를 이용하여 비동기적으로 서버와 데이터를 교환하는 방식

       # 장점
          1. 웹서버에 내용을 전송해도 새로고침을 안해도 됨
          2. 비동기적 데이터 교환이 이뤄짐 = 데이터 전송과 관련없이 화면이 유지되고 사용자는 조작이 가능
              -> (참고!) 화면 전환없이 이뤄지는 요청과 리턴이기에 ajax를 통한 통신을 주고받는 기능에서는 다른 페이지로 연결하여 새로고침을 유발하는 redirect나 render 같은 함수를 server.js의 API {}안에 써봐야 작동하지 않음.. 
          3. NodeJs 환경에서는 Js를 사용하므로, 서버나 화면에서나 같은 방식으로 데이터를 주고받기 쉽다
             (JS의 fetch() 비동기 함수를 사용하는걸 추천)

       # 단점
          : 기본적으로 버튼을 지원하는 FORM 태그랑 다르게, JS의 이벤트리스너를 통해 스스로 버튼 동작과 기능을 연결시킬 줄 알아야 해서 좀 과정이 귀찮음

       # 관련 함수 사용법
          1. fetch API
              : fetch('도메인', { method : 'HTTP메서드' , headers : { 'Content-Type' : 'application/json' or 'html', body : JSON.stringify( { object멤버명 : 원하는 멤버값 , ... ,  object멤버명2 : 원하는 멤버값2} ) } })
                 -> 이후 받아온 값을 쓰고 싶은경우?
                     -> (주의) fetch api를 통해 받아온 값은 반드시 json이나 text 등 다른 형식으로 전환을 해줘야 함 <-> axios는 그딴거 없어도 됨
                     
                     1. then, catch, finally 구문을 쓰던가
    
                        ex) fetch('도메인')
                            .then( (응답) => 응답.json) )            <- (주의) 반드시 받아온 결과값을 변환부터 해야함
                            .then( (result) => { 성공시 실행할코드})
                            .catch((error)=>{ 인터넷문제 등으로 실패시 실행할코드 })
    
                     2. async await를 사용하여 비동기 코드 진행을 일부 동기적으로 통제
                         -> (중요!) await가 붙으면, 해당 함수 {}안의 해당 비동기코드가 응답이 돌아올떄까지 이를 기다려줌
                         -> 그런 의미에서 fetch를 통한 API 호출은 async await를 사용시 반드시 await를 붙여줘야함.. 그래야 fetch가 끝날떄까지 기다려 줌 
    
                        ex) document.querySelectorAll('.data').addEventListener('click', async function(e){
                              let result = await fetch('도메인' , { method : 'GET' }).json;
                              await (result) => { 성공시 실행할코드 };
                            });
    
                @ 2번째 parameter인 JS객체의 멤버변수에 대해 설명
                   - method : HTTP메서드가 뭔지를 함수에 기입
                   - headers : HTTP의 headers 영역에 들어갈 메타정보를 JS객체 형태로 기입.. (Content-Type를 기입하는 이유는 이게 HTML인지 JSON인지를 받는 쪽에서 알아먹게 하기 목적)
                   - body : 원하는 데이터 형식를 JSON 형식(= js객체, js배열을 string 형식으로 제작)으로 담음

                @ fetch 사용시 주의점
                   1. fetch api를 통해 받아온 값은 반드시 json이나 text 등 다른 형식으로 전환을 해줘야 함
                   2. fetch를 통해 server.js의 API를 호출하고, 그 {}안에서 redirect나 render로 다른 페이지로 이동시키는 코드는 form태그나 a태그를 통한 API 호출처럼 바로 동작하지 않음
                       -> (추정) 비동기적으로 서버와 데이터를 교환하는 fetch api를 사용할 경우, 새로고침이 일어나지 않게 설계되었기에.. redirect 결정은 화면의 fetch 체이닝 로직 영역에서 결정함..
                            -> server.js의 redirect나 render로 다른 페이지로 이동시키는 커맨드에 반응하지 않게하고, 그 redirect(url)를 fetch의 체이닝 응답결과에 포함시켜 브라우저 주소창인 window.location.href 요소에 바로 주입해 해결

          2. axios 라이브러리
              : axios 설치후, axios.HTTP메서드('도메인명')을 통해 웹서버 API를 호출하면, 알아서 받아온 값을 json으로 바꿔주기까지 함
                (= 받아온 값은 반드시 json이나 text 등 다른 형식으로 전환을 해주는 과정 생략)
                    -> 이후 받아온 값을 쓰고 싶은경우?

                       1. then, catch, finally 구문을 쓰던가
      
                          ex) axios.get('도메인')
                              .then( (result) => { 성공시 실행할코드})
                              .catch( (error) => { 인터넷문제 등으로 실패시 실행할코드 })
      
                       2. async await를 사용하여 비동기 코드 진행을 일부 동기적으로 통제
                           -> (중요!) await가 붙으면, 해당 함수 {}안의 해당 비동기코드가 응답이 돌아올떄까지 이를 기다려줌
                            -> 그런 의미에서 axios 통한 API 호출은 async await를 사용시 반드시 await를 붙여줘야함.. 그래야 axios http메서드 함수가 끝날떄까지 기다려 줌 
      
                          ex) document.querySelectorAll('.data1').addEventListener('click', async function(e){
                                let result = await axios.get('도메인');
                                await (result) => { 성공시 실행할코드 };
                              });


- rendering의 종류
   1. server-side rendering (SSG)
       : 서버측에서 HTTP API요청을 받으면, 그 요청에 맞는 HTML을 구성해서 CLIENT에게 보내주고, CLIENT측 브라우저는 이를 화면에 랜더링해주기만 하는 방식
          -> 1) DB에서 데이터 뽑아서
             2) 글목록.html 파일에 꽂아넣고
             3) 그 html 파일을 서버에서 보내줌

         EX) EJS (JSP 1.5에서 쓰던 그 템플릿 기호를(<% %>, <%= %>, <%- %>)을 사용함 )
   
   2. client-side rendering (CSG)
       : 서버측이 HTTP API요청을 받으면, DB에서 단지 데이터(보통은 JSON형식)를 보내주고, CLINET측은 그 받은 데이터를 기반으로 HTML구조를 재구성해서 다시 랜더링해 화면에 뿌리는 방식
          -> 1) 서버에 GET요청으로 DB데이터를 가져와서
             2) 그걸 html로 만들어서 보여줌


- Java & ECMA Script
   : HTML로 이루어진 웹페이지를 동적으로 제어하고, 여러가지 기능을 넣기 위해 만들어진 하이브리드 패러다임 기반 언어
      -> 브라우저에서 웹페이지를 통제하는데 사용하는 OOP, Funtional 등등 각종 패러다임에 대응가능한 프로그래밍 언어
         (= 일반적으로 Script로 작성된 프로그램은 브라우저에 내장 된 Script 엔진이 읽고 수행함)
        

- Nodejs
   : 구글이 크롬 안에 넣은 Script 엔진인 V8의 성능이 너무 좋기에, 독립적으로 이를 일반 런타임 환경에서도 실행 가능하도록 출시한 V8기반 Script 파일 실행기
     (= 쉽게 말해, Nodejs와 함께라면 브라우저 없이도 어떤 환경에서라도 JS기반 프로그램을 전부 실행할 수 있음)
   
    # Nodejs 장점
       : Script로 다 해먹을 수 있음 + js의 장점을 기본적으로 서버구축에 적용이 가능함

         1) JS로 확장성 있는 네트워크 애플리케이션 백엔드까지 구축할 수 있기 때문!!!!!
            (= JS의 특유의 이벤트 루프와 비동기 입/출력(= Non blocking I/O)와 같은 특징들을 그대로 서버에 Script만 알아도 활용이 가능함!)
  
         2) Script만 알아도, 프론트와 백엔드 전부를 커버 가능하다..
            (= 웹개발은 Script로 대동단결 쌉가능...)  
  
         3) 검증된 비동기 입/출력(= Non blocking I/O) 코드가 파일 입/출력, DB 입/출력 명령에 기본적으로 적용이 되어 있음

    # Nodejs 단점
       : 기존 Script 언어의 단점 역시 공유함

         1) 쓰레드가 1개라는 JS의 고유의 약점으로 인해, CPU를 많이 갈궈야하는 작업(이미지 변환, 동영상 압축, 숫자 계산)에는 성능도 좋지 않음
  
         2) 동적 타입 언어이기에 타입 관련 불안정성도 같이 가져감
             -> BUT! 타입스크립트를 사용하면? 전부 해결 가능

    # Nodejs + Express로 서버 구축하는법
      1. nodejs 설치
      2. 작업폴더만들고 에디터로 오픈
      3. 터미널에 npm init -y 입력 = node 서버 초기화 작업
      4. 터미널에 npm install express 이것도 입력 = express 프레임워크 설치
      5. server.js 파일을 프로젝트 가장 바깥쪽에 생성 후, 아래 코드 작성하여 express 프레임워크를 모듈로 불러온 뒤, 
          -> 서버 세팅과 구동을 위한 보일러플레이트 코드(Boilerplate code) 작성

             const express = require('express');
             const app = express();
             
             app.listen(8080, function () {         <- app.listen() 부분 : 실제 서버 8080포트에 띄우라는 뜻
               console.log('listening on 8080')
             }); 

             app.get('/', (요청, 응답) => {          <- app.get(URL) 부분 : HTTP get 메서드로 도메인 자체 호출시, '반갑다'라는 글자를 보냄
               응답.send('반갑다')
             }) 

      6. 터미널에 node server.js 를 입력 = 서버 미리보기 띄우기
      7. http://localhost:8080으로 접속
      8. npm install -g nodemon 입력 = nodemon 설치 (= 소스변경 후, 서버 자동으로 재시작해서 반영해주는 프로그램)
          -> nodemon server.js로 실행


- Express 프레임워크
   : 웹이나 모바일 환경 기반 애플리케이션을 위한 Node.js 기반 웹 애플리케이션 프레임워크로 주로 웹서버의 API와 관련된 server.js에 사용
      -> 프레임워크인 이유?
          : 사용법이 까다롭고 딱딱하나, 이 녀석이 시키는데로 하면 쉽고 빠르고 간편하게 사용자가 원하는데로 서버 환경 커스터마이징이 가능함


    # express().Router()
       : router 역할의 JS파일에 위치한 API들을 호출하게 해주는 express 라이브러리의 router 기능을 활용하기 위해 사용하는 함수
           -> express().Router()의 return값은 router 역할의 JS파일 내에서 server.js에서 선언한 express()와 마찬가지로 자신을 기반으로 각종 Express 기반 메서드들을 사용가능함
              (= express().Router() 또한 express()를 통한 return값과 호환된는 형식의 객체를 가짐을 추측가능)

              ex) require('express').Router().use('/', (요청, 응답, next) => {
                      console.log(new Date())
                      next()
                  }) 

    # Express 기반 메서드
       : express()의 결과로 반환된 객체 내부의 함수들

       1. express().listen(포트, () => console.log('접속 성공 메시지') )
           : 해당 포트번호를 통해 통신하는 웹서버를 띄운 뒤, 성공하면 성공메시지를 터미널에 보내라는 명령어  

       2. express().HTTP메서드('url', (생략 가능) 미들웨어 함수명 or 무명 미들웨어 함수, (요청parameter, 응답parameter) => { 내용 } ) seris
           : 클라이언트에서 웹서버로 API를 호출할 때, 사용하는 메서드 
       
             1) express().http메서드명('url', (요청parameter, 응답parameter) => { API내용 } )
                 : express 기반으로 만들어진 서버 객체에 HTTP 메서드로 해당 URL을 요청하면, 그에 해당하는 내용을 응답하도록 API를 구성하는 메서드
      
                   @ URL 파라미터 문법('URL/:parameter명')을 사용한 URL 설계
                      : ':parameter명'을 url에 붙임으로서, url값이 입력시 해당 :parameter명 영역의 값을 웹페이지 API 스코프 내부에서 '요청.params'를 통해 JS객체 형식으로 한 큐에 볼 수 있음
  
                         ex) [웹페이지에서 API를 호출시 정해진 부분에 URL 파라미터 기입]
                                  
                              document.querySelectorAll('.list')[<%= i %>].addEventListener('click', function(e){
                                 fetch('/detail/ + e.target.dataset.id, { method : 'GET' })
                              });
                            
                             [server.js에서는 url 파라미터를 ':ID명'으로 기입 후, 보낸 내용들을 '요청.params'를 통해 읽을수 있음]
                         
                              app.get('/detail/:id', async (요청, 응답) => {
                                 let result = await db.collection('post').findOne({_id : new ObjectId(요청.params.id)});   <-  요청.params 구성은 [ {para1 : para1값} , {para2 : para2값} ] 이고, 요청.query.id 이런식으로 접근 가능
                                 응답.render('detail.ejs', { 상세글 : result })
                              });
  
                   @ queryString 문법('URL?데이터이름=데이터값&데이터이름2=데이터값2')을 사용한 URL 설계
                      : 웹페이지에서 fetch API나 a태그의 url에 ? 이후 데이터이름=데이터값을 페어로 &을 기점으로 하나하나 url에 기입하여 입력시..
                         -> 서버 API 스코프는 url에 아무런 대처를 하지 않아도, 내부에서 '요청.query '를 통해 JS객체 형식으로 한 큐에 볼 수 있음
                      
                            ex) [웹페이지 event설정을 통한 fetch API에 쿼리스트링 기입]
                                  
                                 document.querySelectorAll('.list')[<%= i %>].addEventListener('click', function(e){
                                    fetch('/detail?id=' + e.target.dataset.id, { method : 'GET' })
                                 });
                            
                                [server.js에서는 아무런 url 파라미터 같은걸 안 써줘도 보낸 내용들을 '요청.query'를 통해 읽을수 있음]
                                
                                 app.post('/detail', async (요청, 응답)=>{
                                    await db.collection('post').deleteOne( { _id : new ObjectId(요청.query.id) } );    <-  요청.query의 구성은 [ {id : id값} , {name : name값} ] 이고, 요청.query.id 이런식으로 접근 가능
                                    응답.render('detail.ejs', { 상세글 : result })
                                 });
  
                   @ 콜백함수의 내용을 통한 응답내용 메서드
                      a. 응답parameter.send('보내고 싶은 내용')
                          : 해당 express HTTP 메서드의 요청에 대해 화면에 메시지를 보내고 싶은 경우 사용하는 메서드
      
                      b. 응답parameter.sendFile('보내고 싶은 파일경로명')
                          : 해당 express HTTP 메서드의 요청에 대해 파일을 보내고 싶은 경우 사용하는 메서드
                             (= 주로 HTML 파일을 보냄으로서, 화면을 전환할 때 사용함)
      
                      c. (템플릿 엔진 페이지로 전환) 응답parameter.render('EJS파일명.ejs', { ejs파일에서의 DB데이터 변수명 : API내 DB데이터 변수명 , ...  });
                          : 해당 express HTTP 메서드의 요청에 대해 지정한 템플릿 엔진과 받은 DB변수를 사용하여 템플릿 파일을 SSR 렌더링해서 사용자에게 보내라는 명령어
                             (= 템플릿 파일을 렌더링하여 사용자에게 동적으로 웹페이지로 보냄으로서, 화면을 전환할 때 사용함)
      
                      d. 응답parameter.redirect('url명')
                          : 해당 express HTTP 메서드의 요청 프로세스를 다른 API가 처리하도록 떠넘기게 처리 
                            (= 주로 강제로 페이지 이동시키는 사용)

                      e. 응답parameter.redirect('back')
                          : 해당 express HTTP 메서드의 요청 프로세스를 해당 API를 호출한 이전 페이지의 URL의 API가 처리하도록 떠넘기게 처리 
      
                      f. 응답.status(HTTP status 숫자)
                          : 해당 express HTTP 메서드의 요청 프로세스에 응답시 현재 status를 클라이언트에 전달할 때 사용
                             -> 여기에 체인메서드를 통해 .send()메서드로 메시지 보낼수도 있음
      

             2) express().http메서드명('url', 미들웨어 함수명 or 무명 미들웨어 함수, (요청parameter, 응답parameter) => { API내용 } )
                 : express 기반으로 만들어진 서버 객체에 HTTP 메서드로 해당 URL을 요청하면? 미들웨어 내용을 실행하고 본 API를 실행하도록 구성하는 메서드
                   (= 함수명 or 무명함수는 자동으로 API 요청받고 응답코드 실행하기 전 사이시간에 실행됨)

                   @ express().http메서드명()을 사용한 미들웨어 설정시 주의사항
       
                      a. (중요!) 미들웨어 자리에 위치한 함수의 parameter는 위치에 따라 자동으로 용도가 결정됨
                      
                        - 1번째 paramter
                           : API 요청 관련 정보 객체
                             (요청.body, 요청.query, 요청.user 다 사용가능)
                             
                        - 2번째 paramter
                           : API 응답 관련 정보 객체 
                             (= 응답.redirect, 응답.send, 응답.render 다 사용 가능)
                                -> BUT! 응답객체를 미드웨어 안에서 작성하고, 이걸 호출하게 된다면, 본 API코드까지 넘어가지 않음
                                   (= 미드웨어의 응답객체 코드 = 함수 {} 안에서의 return 코드)
                               
                        - 3번째 paramter
                          : 콜백으로 쓸 미들웨어가 끝났음을 알리고 본 API의 응답코드로 넘어가게 해주는 next() 함수
    
                             ex) function 함수(요청, 응답){             <- 1개의 parameter만 들어갔으니, 1번째 parameter는 API 요청 관련 정보 객체를 가진다
                                 if(요청.user){ 
                                   로그인했군~ 
                                 } else {
                                   응답.send('로그인안했는데요?')        <- 작동되는 순간 본 API코드는 실행X (= API {} 탈출), 그래서 조건문으로 분기 작성
                                 }
                               }
                          
                               express().http메서드명.get('/어쩌구', 함수, (요청, 응답)=>{ API내용 });
                       
                             ex) express().http메서드명('/어쩌구', (요청, 응답, next() ) => { 미들웨어 내용 } , (요청, 응답)=>{ API내용 });
       
          
                      b. 미들웨어를 여러개 사용하고 싶으면, [함수1, 함수2, 함수3] 이렇게 array 형태로 넣는거도 가능함
         
                          ex) express().http메서드명('/어쩌구', [함수1, 함수2, 함수3] , (요청, 응답)=>{ API내용 });


             3) express().http메서드명('*', (요청parameter, 응답parameter) => { API내용 } )
                 : express 기반으로 만들어진 서버 객체에 HTTP 메서드로 현재 입력된 URL 이외의 내용을 요청하면, 그에 해당하는 내용을 응답하도록 API를 구성하는 promise객체 기반 메서드
    
    
       3. express().use((생략가능) URL명, 미드웨어 함수명 or 무명 미드웨어함수) seris
           : 특정 함수내용을 미들웨어로서 그 밑에 위치한 모든 express().http메서드명()을 사용한 API에서 작동하게 하고 싶을 경우 사용
              -> 해당 코드 하단의 모든 express().http메서드명()을 사용한 API들은 use()안의 미드웨어 함수 내용을 미드웨어로서 실행함
                 (= (중요!) 위치에 따라 적용범위가 달라진다 ...이 말씀)

              -> use() 함수의 1번째 paramter에 'url명'을 적으면, 해당 url명으로 시작되는 API만 골라서 미들웨어를 적용해줌 

                 ex) express().use('/어쩌구', checkLogin)   
                      -> 해당 코드 하단의 express().http메서드명() 중 URL이 '/어쩌구'로 시작되는 API들은 미들웨어로 checkLogin을 사용...


             1) express().use(express.static(__dirname, '목표 static 폴더 경로(보통은 /public )'));  
                 : express.static는 특정 폴더안의 파일들을 static 파일로 지정할 수 있으며, use()메서드를 통해 express 객체가 해당 폴더의 내용을 쓸 수 있도록 등록하는 메서드

             [express 환경에서 router 기능을 쓰기 위한 방법]
             2) express().use((생략가능) URL명, require('router JS 주소'))
                 : URL이 '/어쩌구'로 시작되는 API들이, 특정한 공통점을 주제로 제작된 router용도의 JS 파일의 express().http메서드명()기반의 API들을 호출하게 해주는 용도의 함수
                   (= 특정 URL을 기점으로 API들이 작동되도록, 어떤 JS 파일을 모듈로서 불러주는 require() 함수를 미들웨어함수로서 사용하여 그 결과값인 router 객체르 바탕으로 작동하는 본 로직이 router파일의 API를 호출 가능)
                       -> 얘들도 결국 근본적으로는 express().http메서드명()기반으로 작동하는 코드를 모아둔 JS파일에 불과함
                          (= (중요) express().use(미드웨어 함수명 or 무명 미드웨어함수) 코드 밑에 존재한다면, 그 함수들을 전부 미드웨어 함수로 작동시킴)   

                           ex) express().use('/', require('./router/theme.js') );
                                -> url을 이렇게 쓰면 해당 router 파일내부의 API는 모든 url을 대상으로 작동가능성이 존재함

                           ex) express().use('/board', require('./router/board.js') );
                                -> url이 '/board'로 시작하는 API를 호출받는다면, ./router/board.js 파일에서 해당 API를 찾는것을 의미
                                   (= router 페이지인 board.js에서 또한 require('express')를 통한 모듈 import 가 완료되어야 하며, require('express').Router()까지 붙여서 작성시켜야 함)                                

                   @ routes(라우트)
                      : 웹서버의 API가 호출되었을때, 어떤 화면을 응답으로서 보내는 역할을 하는 경우 그 API를 route(노선)라고 부름
                          -> router : 호출되는 API에 따라 응답되는 화면을 전문적으로 중계해주는 역할을 하는 파일이나 역할을 통칭하는 개념

                   @ express().Router()
                      : router 역할의 JS파일에 위치한 API들을 호출하게 해주는 express의 router 기능을 활용하기 위해 사용하는 함수
                          -> express().Router()의 return값은 router 역할의 JS파일 내에서 server.js에서 선언한 express()와 마찬가지로 자신을 기반으로 각종 Express 기반 메서드들을 사용가능함
                             (= express().Router() 또한 express()를 통한 return값과 호환된는 형식의 객체를 가짐을 추측가능)

                             ex) require('express').Router().use('/', (요청, 응답, next) => {
                                     console.log(new Date())
                                     next()
                                 }) 

             [하단의 2개의 코드는 express 환경에서 사용하는 미들웨어로 이를 통해 API에서 요청시 들어온 데이터를 '요청parameter.body' 한 방으로 바로 JS객체로 파싱된 형식으로 볼 수 있음 ]
      
             3) express().use(express.json())
                 : express 라이브러리 환경에서 JSON 형태로 들어온 요청(request)의 body 영역을 파싱(parse)하기 위해 사용되는 미들웨어(middleware)
                    -> 이를 사용하지 않을 경우, 템플릿 엔진으로부터 API요청이 들어온 JSON 데이터의 body영역이 인간이 알기 어려운 용어로 전달되거나 예기치 못한 에러가 발생할 수 있음
      
             4) express().use(express.urlencoded())
                 : express 라이브러리 환경에서 form태그나 멀티파트 등 JSON 형태가 아닌 URL에 데이터가 포함되어 들어오는 형태로 들어온 요청(request)의 body 영역을 파싱(parse)하기 위해 사용되는 URL 인코딩 관련 미들웨어(middleware)
                    -> 이를 사용하지 않을 경우, 템플릿 엔진으로부터 API요청이 들어온 JSON 이외 데이터의 body영역과 URL에서 얻은 데이터가 인간이 알기 어려운 용어로 전달되거나 예기치 못한 에러가 발생할 수 있음
       
                   @ {extended:boolean}
                      : urlencoded 미들웨어에서 전달된 url queryString을 보안 이슈가 있는 중첩 객체를 통해 파싱할건지를 결정하는 설정값
                         -> 'url?데이터명&데이트값' 이런 식으로 사용하는 그 queryString 맞으니 당연히 보안문제가 생긴다는 의미로.. 그래서 보안성 관련 확장을 허용할지 묻는거
                             (= 결과적으로 true, false에 따라 파싱에 사용하는 query String 라이브러리가 달라짐)
  
                                -> true (기본)  : 객체 형태로 전달된 데이터 내에서 또 다른 중첩된 객체를 허용함 (= body-parser 모듈을 사용가능하게 하는 초석 )
                                                   -> url 쿼리 스트링을 파싱하는데, 따로 설치가 필요하지만 추가적인 보안 확장이 가능한 npm qs 라이브러리 사용함
                                   false        : 객체 형태로 전달된 데이터 내에서 또 다른 중첩된 객체를 허용 X
                                                   -> url 쿼리 스트링을 파싱하는데, node.js에 기본으로 내장된 queryString 라이브러리 사용함



       4. express().set() seris

           1) express().set('view engine', '템플릿 엔진명');
               : express 라이브러리 환경에서 '템플릿 엔진'을 쓸 수 있게 하는 코드 

                 ex) app.set('view engine', 'ejs');


- passport 라이브러리
   : 로그인 기능 구현시, session, jwt, OAuth 중 원하는 방식을 쉽게 사용해서 구현할 수 있도록 하는 Node.js 기반 라이브러리

    # passport 라이브러리 이해사항 참고사항

      1. IIFE(Immediately Invoked Function Expression) 패턴
          : 정의한 즉시 호출되어 작동하는 함수 표현식으로.. 함수 코드가 로드되는 시점에서 바로 작동하게 설계되어 있는 패턴의 코드
            (= 무명 함수 내부에 있는 변수들은 외부로 노출 X + 함수 안에서 모든 게 끝나니 변수 선언과 parameter를 통한 호출같은 짓으로 인한 전역 스코프 오염 X)
               -> 함수를 정의하고 ()로 감싼뒤, 실제로 투입할 parameter를 꽁무니에 (parameter1, .. , parameter2) 이런식으로 작성해서 마무리하면 됨
    
               @ IIFE 문법 
                  1) (function() { 함수 내용 } )(parameter1, .. , parameter2);
                      : ()안 함수 내용을 parameter1, .. , parameter2를 기입해서 호출하여 실행함
                
                        ex) 무명함수가 정의된뒤, name으로 정의된 paramter 변수 자리에 'Alice'라는 내용을 기입하여, 해당 무명함수를 호출하여 실행
      
                             (function(name) {
                                console.log('Hello, ' + name);
                             })('Alice');
    
                  2) 함수반환함수호출(호출함수parameter들)(parameter1, .. , parameterN);
                      : (중요!) JS에서는 함수를 반환하는 함수의 경우 바로 ()를 열고 반환된 함수의 parameter의 갯수만큼 parameter1, .. , parameterN를 기입하면 그것을 기입하여 반환한 함수를 호출하여 실행해 줌  
                          -> JS에서는 함수 또한 1급 객체라 paramter와 return값으로 쓰일 수 있기 때문 
                          -> 이게 콜백함수를 paramter로 넣으면 참 무궁무진하게 응용이 가능하다...

                        ex) parameter가 1개인 어떤 함수를 return해주는 iife라는 함수 바로 옆인 paramter 기입 자리에 'Alice'라는 내용을 기입하여 return된 함수를 호출하여 실행
      
                             iife('parameter')('Alice') = 'parameter'라는 parameter를 가지는 iife가 반환하는 함수('Alice')

                        ex) parameter가 1개인 어떤 함수를 return해주는 무명함수를 콜백함수로 가지는 iife라는 함수 바로 옆인 paramter 기입 자리에 'Alice'라는 내용을 기입하여 return된 함수를 호출하여 실행
      
                             iife('parameter', () => {return 어떤함수(param1)} )('Alice') = 어떤함수('Alice')


      2. process.nextTick(무명함수)
          : Node.js 환경에서 작업시간이 오래걸리는 사이드이펙트 코드들을 나중에 주요 작업들이 끝난뒤 실행시키고 싶을 때, parameter인 무명함수 {}안에 내용으로 해당 코드들을 입력함

      3. Strategy 객체
          : passport 라이브러리의 회원 로그인 인증 방식에 대한 기능 차이를 효율적으로 구성하고자, 디자인 패턴 중 strategy(전략) 패턴 구조를 사용
             -> passport 라이브러리의 각 로그인 방식에 필요한 js객체는 Strategy 객체를 상속 기반으로 삼아 구성됨

           @ 로그인 인증 방식에 따른 상속된 strategy 객체의 종류
              -> 이 녀석들을 구현할 로그인 방식에 따라 passport.use()안에 Strategy 생성자 함수 방식으로 넣으면 됨

                  1) Local Strategy(passport-local)
                      : 로컬 DB에서 로그인 인증 방식

                  2) Social Authentication (passport-kakao, passport-twitter 등)
                      : 소셜 네트워크 로그인 인증(OAuth) 방식

      4 connect-mongo 라이브러리 
         : passport 라이브러리 사용시, 생성한 session의 데이터들을 mongoDB에 저장하여 안정적으로 관리하고 싶을떄 사용하는 라이브러리
           (= passport 라이브러리의 세션데이터 저장 DB를 mongoDB로 연결하기 위한 미드의 미드웨어)
               -> 이 녀석을 깔면, passport 라이브러리의 session 관련 설정시, 저장 DB관련 정보인 store 멤버변수에 원하는 mongoDB 관련 정보를 쉽게 넣을 수 있음 
                   -> connect-mongo 라이브러리 설치 및 passport와의 연계법
                       1) 터미널에 npm install connect-mongo 입력 
                       2) server.js 파일에 아래 코드 작성하여, 라이브러리 사용을 위한 모듈 import 코드 작성
                 
                           ex) const MongoStore = require('connect-mongo')
                 
                       3) passport 라이브러리 session 설정 관련 항목에 store 변수에 다음과 같은 내용을 추가
                           -> 그러면, 알아서 mongoDB에 sessions라는 컬렉션을 만들고 거기에 세션을 알아서 보관하고, 유효기간 지나면 자동으로 삭제해줌

    # passport 라이브러리 사용법
      1. 터미널에 npm install express-session passport passport-local 입력 
          -> passport        : 회원인증 도와주는 메인 라이브러리
          -> passport-local  : 아이디/비번 방식 회원인증쓸 때 쓰는 라이브러리
          -> express-session : 세션 만드는거 도와주는 라이브러리

      2. server.js 파일에 아래 코드 작성하여, 설치한 3개의 라이브러리 사용을 위한 보일러플레이트 코드(Boilerplate code) 작성

         ex) const session = require('express-session')
             const passport = require('passport')
             const LocalStrategy = require('passport-local')
             
             app.use(passport.initialize())
    
             // express-session 라이브러리를 통해 세션을 만드는 과정.. session() 안의 parameter로 넣을 js객체를 통해, session의 속성 지정 가능
             app.use(session({
               secret: '암호화에 쓸 비번',           <- secret : 암호화에 사용한 문자열... 짧으면 뚫리게 됨..
               resave : false,                      <- resave : 유저가 요청날릴 때 마다 session데이터를 다시 갱신할건지 여부
               saveUninitialized : false ,          <- saveUninitialized : (기본값 false) 유저가 로그인 안해도 세션을 저장해둘지 여부
               cookie : { maxAge : 1000 , ... }     <- cookie : (기본값 2주) 해당 세션의 유효기간과 관련된 변수 {}안에 내용을 입력.. 단위는 1/1000초
               store : MongoStore.create({          <- store  : 세션 데이터를 특정 DB 종류에 저장하기로 결정하여, 그와 관련된 connect-DB명 라이브러리를 깔면 그와 관련 설정을 하게 함
                 mongoUrl : '님들 DB접속용 URL~~',               -> connect-mongo 라이브러리를 설치 뒤, MongoStore.create 함수에 DB주소와 DB명을 담은 parameter 객체를 통해 session 데이터들을 저장하고 관리해 줌
                 dbName: 'forum',
               })
             })) 
         
         // passport 라이브러리의 session을 만드는 코드 (express-session를 통해 지정한 세션의 속성 사용)
         app.use(passport.session()) 

      3. server.js 파일에 3가지 코드 추가로 작성하여, 로그인 기능에 필요한 기능 코드에 대한 보일러플레이트 코드를 작성

          @ 로그인 정보 검증 담당 코드
            
            - 선언법
              passport.use(new Strategy상속객체 (무명 콜백함수 (아이디, 비번, 콜백함수) => { 유저 입력정보 검증 코드 })
               : passport 라이브러리에서 유저가 로그인 시도시 제출한 아이디 비번이 각 Strategy 방식이 추구하는 방식과 맞는지를 검증하는 부분을 담당하는 함수 선언
                  -> BUT! 사용시에는 본 API전에 작동하는 미들웨어 함수로서 호출이 되어야 함..
                     (= 호출법을 참고해라)

                      ex) passport.use(new LocalStrategy(async (아이디, 비번, 콜백함수) => {
                          
                              let result = await db.collection('user').findOne({ username : 아이디})
                          
                              if (!result) {
                                  return 콜백함수(null, false, { message: '아이디 DB에 없음' })
                              }
                          
                              if (result.password == 비번) {          <- await bcrypt.compare(비번, result.password) : hashing 처리된 비밀번호와 대초해야 한다면, bcrypt라이브러리의 compare 함수를 사용가능  
                                  return 콜백함수(null, result)
                              } else {
                                  return 콜백함수(null, false, { message: '비번불일치' });
                              }
                          }))
                
                [로직 흐름]
                  1. Strategy상속객체의 생성자 함수의 parameter인 id, password, 콜백함수를 paramter로 가지는 무명함수는 id, password의 검증결과에 따라 다른 내용을 실행하는 '콜백함수'를 실행되도록 설계
                  2. 그렇게 실행된 무명함수의 콜백함수를 통해 Strategy상속객체 내부의 멤버변수들이 입력되고, passport.use() 함수가 실행되고 로그인 검증 로직이 실행됨
                      -> 추후 웹서버의 API 안에서 passport.authenticate('local', 콜백함수)라는 코드를 통해, 해당 검증 함수를 호출이 가능함.. 
                         (단.. '콜백함수'의 parameter를 제대로 넣지 않으면 로직은 작동 X며, 이를 미드웨어 함수로 실행시켜야 한다는 조건이 따르기에 next()를 콜백함수로 넣어야 함)
                         
            - 호출법
              passport.authenticate('local', 무명 콜백함수(error, user, info) => { 검증결과에 따른 내용 } )(요청, 응답, next)
               : 앞서 선언한 로그인 정보 검증 함수 선언부인 passport.use( new Strategy상속객체( 무명콜백함수(id, password, 콜백함수) )를 호출하여 '콜백함수'인 passport.use를 반환받고, 거기에 콜백함수(요청, 응답, next)로 paramter를 기입해서 미드웨어 함수로서 '콜백함수'인 passport.use를 호출하는 코드
                  -> (주의!) IIFE(즉시호출 함수) 패턴 구조가 사용된 코드이며, 최종적으로 미들웨어 함수로서 본 API 내용 전에 실행이 되어야함
                  -> (중요!) 무명 콜백함수 내용에는 주로 실패에 대한 경우 메시지를 보내거나, 로그인 성공시 어떻게 할지를 적음

                     ex) app.post('/login', async (요청, 응답, next) => {
                             passport.authenticate('local', (error, user, info) => {
                         
                                 if (error) {
                                     return 응답.status(500).json(error)
                                 }
                                 if (!user) {
                                     return 응답.status(401).json(info.message)
                                 }
                         
                                 요청.logIn(user, (err) => {
                         
                                     if (err) {
                                         return next(err)        <-  passport.authenticate()가 미들웨어 함수로서 실행된다는 사실과 의도를 보여주고, 이를 통해 본 API 내용이 실행되게 넘겨줌
                                     } else {
                                         응답.redirect('/list/paging/ver1/1')
                                     }
                         
                                 })
                         
                             })(요청, 응답, next)
                         });

                [passport.authenticate() 호출시 로직 흐름]
                 1) passport.authenticate('local', 무명 콜백함수1(error, user, info) ) = passport.use(new Strategy( 무명 콜백함수2(id, password, 콜백함수) ) 을 호출
                     -> (주의) 각자의 무명 콜백함수는 다른 내용을 가지는 함수

                     -> (무명 콜백함수1의 paramter들)
                          - error : 뭔가 에러시 에러의 내용에 대한 객체가 들어옴
                          - user  : 아이디/비번 검증 완료된 유저정보가 들어옴
                          - info  : 아이디/비번 검증 실패시 에러메세지가 들어옴
            
                  2) 1번의 결과인 무명 콜백함수2의 parameter인 '콜백함수'의 parameter는 2~3개..
                     (= 이는 라이브러리 검증 함수 use를 호출한 API쪽에서 자신의 parameter인 (요청, 응답, next)라는 parameter를 제공하여야 실행이 가능함)
                         -> (중요!) 이를 통해 Passport의 인증 메서드는 요청(request), 응답(response) 관련 내용과, next() 함수를 통해 미들웨어 이후의 본 API코드에 접근할 수 있고 실행이 완료됨
                            (= passport.authenticate('local', 무명 콜백함수1(error, user, info))(요청, 응답, next)라는 최종적으로는 즉시실행코드(iife) 패턴 형식으로 작동하는 미들웨어 함수기에 (요청, 응답, next) parameter가 꼭 있어야 에러가 없음)

          @ session 생성 및 세션id 브라우저 쿠키에 저장 담당 코드
          
            - 선언부
              passport.serializeUser( 무명 콜백함수(로그인 정보 객체, 콜백함수) => { 세션 정보 생성 코드 }))
               : 유저가 로그인시에, 세션 객체를 생성하고 그 중 세션 id를 암호화해서 유저의 브라우저 쿠키에 저장하는 기능을 passport 라이브러리에서 담당하는 함수
                 (= 웹서버의 로그인 기능 관련 API의 코드 중 요청.login() 함수가 호출되어 실행되면 자동으로 실행됨.. )
                     -> 만들어진 세션정보는 유저가 API를 호출할 때마다 자동으로 웹서버 API의 paramter 무명함수의 paramter인 '요청' 객체에 포함되어 웹서버로 전송되기에 API {}안에서 요청.user로 참고 가능
                        (하단의 passport.deserializeUser() 함수를 참고)

                     -> (무명 콜백함수의 paramter들)
                          - 로그인 정보 객체  : 유저의 로그인 정보
                          - 무명 콜백함수     : parameter로 주어진 정보(주로 세션 id와 유저 id)를 이용해 세션 객체를 만들고 입력해주는 함수
                              -> (참고) 세션의 유효기간 같은건 알아서 기록해 줌.. 그러니 가장 중요한 id들을 넣자
                              -> (주의) 단! DB를 연결하지 않으면, 메모리에 세션정보들이 저장됨

                             ex) passport.serializeUser((유저정보, 콜백함수) => {
                                     process.nextTick(() => {
                                         콜백함수(null, { id: 유저정보._id, username: 유저정보.username })
                                     })
                                 }) 

          @ 유저가 웹서버에 API로 요청시, 세션 유효여부 확인 + 웹서버에 세션정보 보내서 참조 가능 기능 담당 코드

            - 선언부
              passport.deserializeUser(async 무명콜백함수(로그인 정보 객체, 콜백함수) => { API요청 세션 검증 및 세션정보 API측의 요청정보에 포함 내용 })
                 : 유저가 웹서버에 API로 요청을 할 때마다, 쿠키에 위치한 유저의 세션 데이터를 서버가 확인하여 검증하고 문제없으면 데이터를 보내주는 passport 라이브러리에서 담당하는 함수
                    -> 검증이 끝났다면, 웹서버는 API 호출시 paramter로 보내는 무명함수의 paramter인 요청객체에 그 로그인 된 데이터를 user라는 멤버변수에 담아줌..
                       (= 각 API의 {} 안에서 '요청.user' 코드를 통해 그 정보에 접근가능하게 함 )

                    -> server.js의 API에서 요청.user._id로 접근가능한 현재 로그인 한 유저의 계정정보가 위치한 collection의 objectId 형식의 고유값은 objectId라는 js객체 형식
                       (= (중요!) server.js에서 new ObjectId 형식의 값은 mongodb 라이브러리에서 정의한 ObjectId라는 형식의 js객체로서 인식됨)
                           -> server.js에서 new ObjectId 형식의 값 비교를 위해서, ObjectId값.equals(ObjectId값) 함수를 사용해야 함
                             (= JS객체 자체는 객체가 저장된 힙영역의 포인터 값을 가짐)
                                ->단! mongodb 라이브러리의 import는 반드시 해야 ObjectId 타입의 메서드인 equals() 함수 사용 가능
                                   (= ejs화면 파일에서 equals를 무턱대고 사용하면 오류가 발생하는 대부분의 원인을 차지)

                    -> (무명 콜백함수의 paramter들)
                         - 로그인 정보 객체  : 유저의 로그인 정보
                         - 무명 콜백함수     : parameter로 주어진 정보(주로 세션 id와 유저 id)를 API에서 사용/참고할 수 있도록 '요청'객체에 보내주는 함수
                             -> (참고) 세션의 유효기간 같은건 알아서 기록해 줌.. 그러니 가장 중요한 id들을 넣자
                             -> (주의) 단! DB를 연결하지 않으면, 메모리에 세션정보들이 저장됨   
    
                            ex) passport.deserializeUser(async (유저정보, 콜백함수) => {
                                
                                    // (하단 참고사항 참고) 유저의 로그인 ID를 이용해 진짜 최신화된 유저정보를 찾음
                                    let result = await db.collection('user').findOne({_id : new ObjectId(유저정보.id) });
                                
                                    process.nextTick(() => {
                                        return 콜백함수(null, result)
                                    })
                                })

                [중요한 참고사항]
                  : (주의) 세션이 만들어진 시기에 따라.. 적힌 유저의 정보와 실제 유저의 정보가 다를 수 있다는 걸 염두에 두고 deserializeUser를 설계해야 함
                     1. 세션에 적힌 유저 로그인 정보를 가져오면
                     2. 그 로그인 정보를 이용해 최신 회원 정보를 DB에서 가져오고
                     3. 그걸 요청.user에 집어넣는 식으로 코드짜는게 좋음
                     4. deserializeUser를 정말 필요한 특정 route(페이지나 API)에서만 실행시킨다면, 필요없는 DB조회를 감소시켜 트래픽 감소와 성능향상에 영향을 줄 수 있음


- bcrypt 라이브러리
   : 로그인 기능 구현시, 비밀번호 hashing 기능을 쉽게 사용가능하게 도와주는 Node.js 기반 라이브러리
      -> 어떤 hashing 알고리즘을 사용할지 + 이를 몇번 반복해서 hashing해줄지 + salt 값을 자동으로 넣어줄지 전부 쉽게 사용가능

    # bcrypt 라이브러리 사용법
      1. 터미널에 npm install bcrypt 입력 
      2. server.js 파일에 아래 코드 작성하여, 라이브러리 사용을 위한 모듈 import 코드 작성

         ex) const bcrypt = require('bcrypt') 
         
      3. 웹서버 API에 hashing 기능을 관련해서, 다음과 같은 코드를 사용 가능
          -> 해당 코드는 비동기로 동작하게 설계되어 있음

          1) bcrypt.hash('문자열', 알고리즘 적용횟수) 
              : '문자열'을 설정된 알고리즘을 횟수만큼 적용해서 hashing처리 함 
                  -> '알고리즘 적용횟수'가 높을수록 hashing 작업을 중첩해서 수행하여 보안성을 높이나.. 웹서버 성능에 영향을 줄 수 있음

          2) bcrypt.compare('문자열', 'hashing 적용된 문자열')
              : 어떤 문자열이 hashing 처리된 어떤 문자열과 같은지 비교하는 함수  
                 -> 문자열 비교기능의 일종의 업그레이드 버전


- dotenv 라이브러리
   : 개발 환경을 구축시, 개발자나 컴퓨터에 따라 다르게 입력되어야 할 환경변수들을 1개의 환경설정 파일에 모아두고, 전역변수로서 접근가능하게 해주는 ';.env 확장자 설정파일' 구축을 돕는 Node.js 기반 라이브러리

     ex) mongoUrl : ''mongodb+srv://admin:lsh916@cluster0.tatoixz.mongodb.~~'
          -> 개발자 마다 다른 DB주소를 가지고 있어 달라질 수 있음

    # 환경변수
       : 개발 환경을 구축하는데 있어 반드시 입력이 필요하지만, 개발자와 컴퓨터에 따라 달라질 수 있어서 구체적으로 입력이 필요한 가변적인 변수
          -> (중요!) 개발 초기에는 하드코딩을 하기도 하지만...  따로 별도의 설정파일용 '.env 확장자'를 가진 파일에 보관하는게 나음
               1) 환경변수 관리가 쉬움
                   : 변동이 생길 가능성이 있는 환경변수만 따로 모아두면, 파일과 내용의 관리가 쉬우며, 소스공유 작업도 편리해짐
               2) 보안을 관리하기 용이함
                   : 환경변수용 설정파일 1개만 특별관리를 한다면, 공유시에 환경변수를 따로 관리하기도 쉬움
                     (= ignore 확장자에 등록해두면, 이게 올라갈 일은 없다.. 이 말씀)

    # dotenv 라이브러리 사용법
      1. 터미널에 npm install dotenv 입력 
      2. server.js 파일에 아래 코드 작성하여, 라이브러리 사용을 위한 모듈 import 코드 작성

         ex) require('dotenv').config();
         
      3. 소스 폴더 최상단에 .env 파일 생성 후 환경변수로 넣을 변수들 하나하나 작성

         ex) mongoDB에 작성할 환경변수 내용들을 상수명으로 지어진 변수명에 기입

             PORT = 8080
             DB_URL = "mongodb+srv://codingapple1@저쩌구" 

      4. 환경변수를 입력할 자리에 입력했던 변수명에 해당하는 변수를 입력하고 싶으면 'process.env.환경변수명'과 같은 형식으로 입력해주기

         ex) app.use(session({
                secret: process.env.SECRET,
                resave : false, 
                saveUninitialized : false,
                cookie : process.env.COOKIE,
                store: MongoStore.create({
                    mongoUrl : process.env.MONGO_URL,
                    dbName: 'forum',
                })
            }))
 
 - multer 라이브러리
    : (formidable 라이브러리) 사용자가 웹서버에 파일을 업로드하는 기능이 필요할 때, 이를 좀 더 쉽게 구축할 수 있게 도와주는 용도의 라이브러리
        -> 당연한 이야기지만, 클라우드 저장소와 매우 크게 관련되어 있는 기능이기에 그와 관련된 에드온에 해당하는 라이브러리들도 존재함 (ex S3)

    # multer 라이브러리 사용법
      1. 터미널에 npm install multer multer-s3 @aws-sdk/client-s3  입력 
          -> multer-s3 @aws-sdk/client-s3는 multer 라이브러이에서 AWS S3와 연계를 위해 필요한 추가적인 라이브러리들
              - multer-s3 : 업로드한 파일을 s3에 쉽게 올릴 수 있게 도와줌 
              - @aws-sdk/client-s3 : AWS 사용시 필요한 부분 

      2. server.js 파일에 아래 코드 작성하여, 라이브러리 사용을 위한 모듈 import 코드 작성

         ex) const { S3Client } = require('@aws-sdk/client-s3')
             const multer = require('multer')
             const multerS3 = require('multer-s3')

             // multer-s3 사용시, S3 연결에 필요한 정보를 받는 객체를 생성 (= @aws-sdk/client-s3 라이브러리 관련 기능)
             const s3 = new S3Client({
               region : 'ap-northeast-2',
               credentials : {
                   accessKeyId : 'IAM에서 발급받은 액세스키',
                   secretAccessKey : 'IAM에서 발급받은 시크릿키'
               }
             })
             
             // multer 라이브러리를 통해 업로드한 파일 저장하는 기능 수행을 수행할 시 필요한 속성인 storage의 내용 입력 storage의 속성값을, S3 버킷(저장소이름), 저장명을 짓는 콜백함수를 설정하여 마무리
             const upload = multer({
               storage: multerS3({
                 s3: s3,                                     <- s3 : 앞서 생성한 S3 객체의 정보값(region, credentials)을 요구
                 bucket: '님들버킷이름',                      <- bucket : 접속할 S3의 bucket(저장소명)
                 key: function (요청, file, cb) {            <- key : 저장소에 파일 저장시 새로 설명할 파일명을 만든 콜백함수 설정
                   cb(null, Date.now().toString())                      -> 원본 파일명은 요청.file을 통해 얻을 수 있음
                 }
               })
             })

      3. 2번의 작업 완료 후, 원하는 API에서에서 upload.함수명()라고 미들웨어를 추가해주면.. 이미지가 들어올 때 마다 S3에 자동으로 업로드 됨 
          -> (중요) 에러코드 발생을 대비하고 싶으면, 그냥 짤 없이 API내부에 upload.함수명()(요청, 응답, (err)=>{ 에러내용 포함 })에 해당하는 함수를 직접 기입해서 미들웨어 형식으로 직접 넣어줘야함
          -> 업로드후엔 URL이 하나 생성되는데 그건 요청.file 아니면 요청.files 안에 location이라는 속성 안에 들어있음.. 
              (= 그 URL을 저장 한 뒤, 추후 이미지 조회시 <img src=" "> 안에 이미지 URL을 집어넣으면 이미지를 html 파일안에서 보여줄 수 있음)

               1) upload.single(‘input의 name속성 이름’)
                   : 단, 1개의 이미지만 업로드 하고 하고 싶을 경우 사용
                      -> 이를 통해 가져오는 file들은 요청.file로 참조 가능하며, file객체로 입력되어 있으니 참고 
                         (= upload.single 함수를 통해 입력되는 속성값은 요청.file이라는 요청객체의 멤버에 입력된 file객체라고 보면 됨)


                     ex1) 미들웨어가 api의 paramtere로 들어간 경우
                     
                         app.post('/add', upload.single('img1'), (요청, 응답) => {

                           // 요청.file : 업로드 된 원본의 파일정보
                           console.log(요청.file)

                           // 요청.file.location : multer라이브러리가 이미지를 s3에 업로드 한 뒤, 그 이미지의 s3내 저장 위치 정보에 해당되는 url
                           await db.collection('post').insertOne({
                             title : 요청.body.title,
                             content : 요청.body.content,
                             img : 요청.file.location         // 나중에 게시글 상세조회시 여기 저장된 이미지 url 정보를 통해 s3에 접근하여 이미지를 가져옴 
                           })

                           (생략)
                         }) 

                     ex2) 미들웨어 upload.함수명()에 오류처리를 하고 싶은 경우
                     
                         app.post('/add', (요청, 응답) => {

                           upload.single('img1')(요청, 응답, (err)=>{
                             if (err) return 응답.send('에러남')

                             // 요청.file : 업로드 된 원본의 파일정보
                             console.log(요청.file)
  
                             // 요청.file.location : multer라이브러리가 이미지를 s3에 업로드 한 뒤, 그 이미지의 s3내 저장 위치 정보에 해당되는 url
                             await db.collection('post').insertOne({
                               title : 요청.body.title,
                               content : 요청.body.content,
                               img : 요청.files.map(file => file.path);          // 나중에 게시글 상세조회시 여기 저장된 이미지 url배열의 요소들을 참고하여 s3에 접근하여 이미지를 가져옴 
                           })

                           (생략)
                         }) 

               2) upload.array(‘input의 name속성 이름’, '업로드 이미지 최대갯수')
                   : 여러개의 이미지를 업로드 하고 싶을 경우 사용
                      -> 이를 통해 가져오는 file들은 요청.files로 봐야하며, files 안의 구조는 file객체 [] 형식으로 되어 있으니 참고 
                         (= upload.array 함수를 통해 입력되는 속성값은 요청.file이 아니라 요청.files이며, 그 안은 file객체의 배열이라고 보면 됨)

               @ Form태그에서 이미지 1장만 첨부     VS     여러장 첨부가능

                  A. 사용하는 미드웨어 함수
                     - 1장    : upload.single(‘input의 name속성 이름’) 
                     - 여러장  : upload.array(‘input의 name속성 이름’, '업로드 이미지 최대갯수')

                  B. 요청 객체에서 사용되는 멤버객체명 
                     - 1장    : 요청.file    (file객체 형식)
                     - 여러장  : 요청.files (file객체의 array 형식)

                  C. 멤버 객체에서 S3의 데이터 URL이 위치하는 멤버변수
                     - 1장    : 요청.file.location
                     - 여러장  : 요청.files.map(file => file.location)
                                (= file객체 중 location만 때서 형성한 array 타입)

      4. 원하는 화면에서 작업해둔 API를 호출하는 form 형식에서 input 태그를 만들어서 이미지를 업로드 할 수 있도록 코드를 작성함
           -> <input multiple> 이런식으로 input태그에 multiple 속성을 넣으면 여러개의 이미지 선택이 가능함!
           -> (주의) enctype="multipart/form-data"를 form 태그의 속성으로 넣어줘야 API로 업로드한 파일정보가 제대로 넘어감

               ex) <form class="form-box" action="/board/add" method="POST" enctype="multipart/form-data">
                       <input type="file" name="img1" accept="image/*">
                       <button type="submit">전송</button>
                   </form> 

      5. 4번까지 완료했으면, 사실상 미들웨어 함수 upload.single('이미지 name속성명')이 S3 버킷에 이미지를 올려줌

