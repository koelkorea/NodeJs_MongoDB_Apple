- 서버(server)
   : 누가 어떤 데이터를 '요청'하면 보내주는(= '응답') 역할을 수행하는 프로그램 
      -> 그 프로그램을 수행하는 실체가 물리적 컴퓨터일수도 있고, 논리적으로 분리된 가상 컴퓨터일수도 있음
         (비슷한 코드를 짜다보니 효과적인 중복방지를 위한 패턴으로 인해, 분리와 조건문 다형성을 활용한 패턴을 적극활용하는 경우가 많을 뿐)

    # 웹서버
       : 누가 어떤 홈페이지 도메인(URL)으로 접속하면 거기맞는 html을 보내주는 서버

    # 포트(port)
       : 내 컴퓨터의 ip가 일종의 국가면, 포트는 항구와 같은 의미로.. 이 포트라는 단위를 기준으로 컴퓨터는 여러 컴퓨터 및 어플리케이션들과의 통신을 구분하여 주고 받을 수 있도록 할당받음 
          -> BUT! 기본적으로 유명한 번호의 포트는 컴퓨터에서 이미 사용하거나, 특정 기능이나 앱이 사용하도록 할당되는 경우가 있는데, 이런건 따로 건드는일 없도록 해 함


- HTTP 메서드
   : HTTP를 통해 서버에 데이터를 어떻게 해달라고 요청하는 동사(Verb)로서의 의미를 가진방식(메서드)으로서 크게 5가지로 구분
     -> 이를 기반으로 어떤 종류의 데이터(Resource)를 작업해달랄지에 대해서는, URI 통해 전달함으로서 서버는 API의 종류를 구분함 
        (널리 사용되는건 get, post2가지)

        1. GET
            : 서버에게 데이터를 달라고 요청할 때 사용 (사용자가 보낸 URL 파라미터가 공개됨)

        2. POST
            : 서버에게 데이터를 보내서, 이를 가공하여 무언가를 요청하기까지 하는 광범위한 작업을 요청시 사용 
              (여기서부터는 사용자가 보낸 데이터 UTL에 보이지 않음)

        3. PATCH
            : 서버에게 이미 존재하는 데이터의 일부를 수정할 때 사용
        
        4. PUT
            : 서버에게 이미 존재하는 데이터면 이를 통째로 바꾸도록, 없으면 추가하도록 할 때 사용

        5. DELETE
            : 서버에게 데이터를 삭제요청시에 사용

- RESTful(Representational State Transfer) API
   : 웹서버에서 URI + HTTP 메서드를 통해, 사용자와 운영자 모두에게 좋은 방식의 웹서버 API를 설계(= 작명)하는 6가지 방법론으로 이해
     (= 그냥 method, URL만 잘 기입해두면 관습적으로 REST하다고 함... )

      1. 일관적인 인터페이스(Uniform Interface)
          : 여러 URL과 method는 전체적인 개념에 일관성이 있어야 함
             - 하나의 URL로는 하나의 데이터를 가져오게 디자인하는게 좋고 
             - 간결하고 예측가능하게 URL과 method를 만드는게 사용자, 운영자 모두에게 좋음 
      
      2. Client-server 역할 구분 
          : 사용자는 사용자고! 서버는 서버다! 
            (= 사용자에게 서버가 할 역할을 맡기거나 DB를 직접 입출력하게 하는 기능을 오픈하면 안됨!)
      
      3. 무상태(Stateless)성 유지
          : 모든 요청들은 서로 의존성이 있는거 보단, 각각 독립적으로 처리되도록 API는 설계되어야 함
      
      4. 캐싱가능함(Cacheable)
          : 웹서버가 사용자들에게 보내는 자료들은 캐싱이 가능해야 좋음
             -> 자주 받는 자료들은 브라우저에서 하드에 저장해놓고 쓸 수 있게 하기에, 사용자나 서버나 트래픽이나 시간 낭비가 없음
      
      5. 계층화된 구조(Layered System)
          : 서버기능을 만들 때 레이어를 걸쳐서 코드가 실행되도록 만드는게, 프로그램의 코드 실행의 역할과 책임을 구분하기 유리함
      
      6. 실행가능한 코드(Code on demand)
          : 서버는 실행가능한 코드를 보냄으로서, 시스템에 유연성과 확장성을 제공할 수 있음

    # (참고) 그 외 API 설계시 도움되는 내용
       1. 단어들을 동사보다는 명사 위주로 구성함 
           -> 동사적 의미는 HTTP 메서드에게 맡기도록 하자

       2. 띄어쓰기는 언더바(_) 말고, 대시(-)를 사용하는게 직관적임
       3. 파일 확장자 쓰지 말기 (.html 이런거)
       4. 하위 문서들을 뜻할 땐 / 기호를 사용함 (하위폴더같은 느낌)

    # (참고) 웹서버 API 로직 작성시, 서버 API를 거치게 될 때 validation처리나 예외처리 코드를 짜는 방법론
        -> 물론 가능한 웹페이지에서 입력을 받기 전에 이를 거를 수 있게하는 로직이 들어가는게 중요함

           1. 필수적으로 들어가야 하는 데이터가 누락되거나, 적절하지 않게 들어갔다??
               : 조건문을 사용하여, 요청시 전달된 데이터 중 필요 데이터가 없거나 입력X 시를 기준으로 처리법을 나누기
                  -> or validation 라이브러리를 쓰는 것도 방법...  
                  
                     ex) express-validator, vinejs, validator 
    
           2. 어떤 코드 영역을 실행시 잠재적으로 에러가 나올수도 있는 코드가 예상된다??
               : try, catch(e) 구문을 통해, 에러가 예상되는 코드를 영역으로 묶은뒤 거기서 일어나는 에러를 처리할 수 있는 catch영역 코드를 작성하기

- (중요) 웹서버에 데이터를 전송하는 방식
  1. URL의 일부로 데이터를 포함해서 보냄..
      : 말 그대로 URL에 데이터를 그냥 무식하게 포함해서 보냄

       # 방법
          1) URL 파라미터
              : NodeJS에서 설정을 통해 URL에서 파라미터로 보낸 정보의 위치를 서버가 찾고 판별할 수 있는 형식을 API의 URL에 적어서, 사용자 측에서 보낸 API 요청에 응답할 때 URL에서 데이터를 특정 변수명으로 대입해서 쓰는 방식 
                 -> 그렇게 받은 정보는 API {} 내부에서 '요청parameter명.params'로 접근하여 해당 URL파라미터들을 모아 기록한 객체에 쓸 수 있음
                    (= '요청parameter명.params' 형식으로 사용이 가능한 이유는 얘도 queryString이나 qs라는 NodeJs의 라이브러리를 사용하기 떄문)

                 ex) app.post('/delete/:id/:name', async (요청, 응답)=>{
                        요청.params = [ {id : id값} , {name : name값} ]
                        요청.params.id 이런식으로 접근 가능
                     });

               @ 장점
                  1. 그나마 보내는 데이터가 어떤 칼럼에서 나오는지를 가리기에 보안적인 면에서 나을수는 있음

               @ 단점
                  1. 약간이나마 서버설정이 필요하다는 단점 존재
                  2. POST 방식을 쓰면 그나마 낫지만, 기본적으로 URL에 데이터를 포함해서 보내기에 보안이 씹망

          2) queryString
              : 아무런 설정이 필요없이 URL에 대놓고, '도메인?데이터이름=데이터값&...' 이런식으로 데이터를 전송하는 방식... 
                 -> 그렇게 받은 정보는 API {} 내부에서 '요청parameter명.query'로 접근하여 해당 URL파라미터들을 모아 기록한 객체에 쓸 수 있음
                    (= '요청parameter명.query' 형식으로 사용이 가능한 이유는 얘도 queryString이나 qs라는 NodeJs의 라이브러리를 사용하기 떄문)

                 ex) app.post('/delete?id=<%= 글목록[i]._id%>&title=<%= 글목록[i].title %>', async (요청, 응답)=>{
                        요청.query = [ {id : id값} , {name : name값} ]
                        요청.query.id 이런식으로 접근 가능
                     });

               @ 장점
                  : 그냥 사용이 ㅈㄴ 간편하며, 어떤 라이브러리나 설정이 필요없이 그냥 기본적으로 지원됨

               @ 단점
                  : POST 방식을 쓰면 그나마 낫지만, 기본적으로 URL에 데이터를 포함해서 보내기에 보안이 씹망
                     -> 그런 중대한 문제가 있어.. express 라이브러리에서 url인코딩 미드웨어(하단 express의 API목록 참고)를 쓸 때.. 그 옵션으로 보안성 확정 여부를 묻는게 존재함
                        (= 기본 queryString의 보안문제를 해결한 qs 라이브러리가 존재함.. npm install qs로 인스톨 가능)

  2. HTML의 FORM태그를 사용해서 전송하는 방법
      : FORM태그의 action 속성에 url을 적고, method 속성에 HTTP 메서드를 적어서 웹서버에 API를 요청함

       # 장점
          : HTML레벨에서 지원하는 방식이기에, 이벤트 동작은 신경 안 써도 되고 상대적으로 화면에서 할게 적은 편

       # 단점
          1. 웹서버에 내용을 전송하면, 새로고침을 하게 됨
          2. 비동기적인 동작이 불가능함 = 전송이 끝날 때까진 아무것도 조작이 불가능함 = 소비자 경험이 ㅈ됨
          3. GET, POST 밖에 HTTP 메서드를 쓸수가 없음
 
             @ NodeJs 환경에서 FORM 태그를 통한 전송에 PUT이나 DELETE 메서드를 쓰고 싶은 경우
                1) AJAX 전송을 쓴다
                2) method를 강제로 변경해주는 라이브러리를 사용
                   
                   ex) method-override
                        1) npm install method-override 터미널에 입력
                        2) server.js에 보일러 플레이트 코드 입력
         
                           const methodOverride = require('method-override')
                           app.use(methodOverride('_method')) 
             
                        3) form 태그에서 url을 날릴 때, '?_method=HTTP메서드' 를 붙이면 다른 HTTP 메서드로 전송 가능하게 덮어써 줌
         
                           ex) <form action="/edit?_method=PUT" method="POST"> </form> 

  3. Ajax(Asynchronous JavaScript and XML)를 사용
      : JavaScript의 함수(fetch)나 라이브러리(express)의 함수를 이용하여 비동기적으로 서버와 데이터를 교환하는 방식

       # 장점
          1. 웹서버에 내용을 전송해도 새로고침을 안해도 됨
          2. 비동기적 데이터 교환이 이뤄짐 = 데이터 전송과 관련없이 화면이 유지되고 사용자는 조작이 가능
          3. NodeJs 환경에서는 Js를 사용하므로, 서버나 화면에서나 같은 방식으로 데이터를 주고받기 쉽다
             (JS의 fetch() 비동기 함수를 사용하는걸 추천)

       # 단점
          : 기본적으로 버튼을 지원하는 FORM 태그랑 다르게, JS의 이벤트리스너를 통해 스스로 버튼 동작과 기능을 연결시킬 줄 알아야 해서 좀 과정이 귀찮음

       # fetch 함수 사용법
          : fetch('도메인', { method : 'HTTP메서드' , headers : { 'Content-Type' : 'application/json' or 'html', body : JSON.stringify( { object멤버명 : 원하는 멤버값 , ... ,  object멤버명2 : 원하는 멤버값2} ) } })

            @ 2번째 parameter인 JS객체의 멤버변수에 대해 설명
               - method : HTTP메서드가 뭔지를 함수에 기입
               - headers : HTTP의 headers 영역에 들어갈 메타정보를 JS객체 형태로 기입.. (Content-Type를 기입하는 이유는 이게 HTML인지 JSON인지를 받는 쪽에서 알아먹게 하기 목적)
               - body : 원하는 데이터 형식를 JSON 형식으로 담음

- rendering의 종류
   1. server-side rendering (SSG)
       : 서버측에서 HTTP API요청을 받으면, 그 요청에 맞는 HTML을 구성해서 CLIENT에게 보내주고, CLIENT측 브라우저는 이를 화면에 랜더링해주기만 하는 방식
          -> 1) DB에서 데이터 뽑아서
             2) 글목록.html 파일에 꽂아넣고
             3) 그 html 파일을 서버에서 보내줌

         EX) EJS (JSP 1.5에서 쓰던 그 템플릿 기호를(<% %>, <%= %>, <%- %>)을 사용함 )
   
   2. client-side rendering (CSG)
       : 서버측이 HTTP API요청을 받으면, DB에서 단지 데이터(보통은 JSON형식)를 보내주고, CLINET측은 그 받은 데이터를 기반으로 HTML구조를 재구성해서 다시 랜더링해 화면에 뿌리는 방식
          -> 1) 서버에 GET요청으로 DB데이터를 가져와서
             2) 그걸 html로 만들어서 보여줌


- Java & ECMA Script
   : HTML로 이루어진 웹페이지를 동적으로 제어하고, 여러가지 기능을 넣기 위해 만들어진 하이브리드 패러다임 기반 언어
      -> 브라우저에서 웹페이지를 통제하는데 사용하는 OOP, Funtional 등등 각종 패러다임에 대응가능한 프로그래밍 언어
         (= 일반적으로 Script로 작성된 프로그램은 브라우저에 내장 된 Script 엔진이 읽고 수행함)
        

- Nodejs
   : 구글이 크롬 안에 넣은 Script 엔진인 V8의 성능이 너무 좋기에, 독립적으로 이를 일반 런타임 환경에서도 실행 가능하도록 출시한 V8기반 Script 파일 실행기
     (= 쉽게 말해, Nodejs와 함께라면 브라우저 없이도 어떤 환경에서라도 JS기반 프로그램을 전부 실행할 수 있음)
   
    # Nodejs 장점
       : Script로 다 해먹을 수 있음 + js의 장점을 기본적으로 서버구축에 적용이 가능함

         1) JS로 확장성 있는 네트워크 애플리케이션 백엔드까지 구축할 수 있기 때문!!!!!
            (= JS의 특유의 이벤트 루프와 비동기 입/출력(= Non blocking I/O)와 같은 특징들을 그대로 서버에 Script만 알아도 활용이 가능함!)
  
         2) Script만 알아도, 프론트와 백엔드 전부를 커버 가능하다..
            (= 웹개발은 Script로 대동단결 쌉가능...)  
  
         3) 검증된 비동기 입/출력(= Non blocking I/O) 코드가 파일 입/출력, DB 입/출력 명령에 기본적으로 적용이 되어 있음

    # Nodejs 단점
       : 기존 Script 언어의 단점 역시 공유함

         1) 쓰레드가 1개라는 JS의 고유의 약점으로 인해, CPU를 많이 갈궈야하는 작업(이미지 변환, 동영상 압축, 숫자 계산)에는 성능도 좋지 않음
  
         2) 동적 타입 언어이기에 타입 관련 불안정성도 같이 가져감
             -> BUT! 타입스크립트를 사용하면? 전부 해결 가능

    # Nodejs + Express로 서버 구축하는법
      1. nodejs 설치
      2. 작업폴더만들고 에디터로 오픈
      3. 터미널에 npm init -y 입력 = node 서버 초기화 작업
      4. 터미널에 npm install express 이것도 입력 = express 프레임워크 설치
      5. server.js 파일을 프로젝트 가장 바깥쪽에 생성 후, 아래 코드 작성하여 express 프레임워크를 모듈로 불러온 뒤, 
          -> 서버 세팅과 구동을 위한 보일러플레이트 코드(Boilerplate code) 작성

             const express = require('express');
             const app = express();
             
             app.listen(8080, function () {         <- app.listen() 부분 : 실제 서버 8080포트에 띄우라는 뜻
               console.log('listening on 8080')
             }); 

             app.get('/', (요청, 응답) => {          <- app.get(URL) 부분 : HTTP get 메서드로 도메인 자체 호출시, '반갑다'라는 글자를 보냄
               응답.send('반갑다')
             }) 

      6. 터미널에 node server.js 를 입력 = 서버 미리보기 띄우기
      7. http://localhost:8080으로 접속
      8. npm install -g nodemon 입력 = nodemon 설치 (= 소스변경 후, 서버 자동으로 재시작해서 반영해주는 프로그램)
          -> nodemon server.js로 실행


- Express 프레임워크
   : 웹이나 모바일 환경 기반 애플리케이션을 위한 Node.js 기반 웹 애플리케이션 프레임워크로 주로 웹서버의 API와 관련된 server.js에 사용
      -> 프레임워크인 이유?
          : 사용법이 까다롭고 딱딱하나, 이 녀석이 시키는데로 하면 쉽고 빠르고 간편하게 사용자가 원하는데로 서버 환경 커스터마이징이 가능함

    # Express 기반 메서드
       : express()의 결과로 반환된 객체 내부의 함수들

       1. express().listen(포트, () => console.log('접속 성공 메시지') )
           : 해당 포트번호를 통해 통신하는 웹서버를 띄운 뒤, 성공하면 성공메시지를 터미널에 보내라는 명령어  

       2. HTTP 메서드 seris
       
           1) express().http메서드명('url', (요청parameter, 응답parameter) => { 내용 } )
               : express 기반으로 만들어진 서버 객체에 HTTP GET 메서드로 해당 URL을 요청하면, 그에 해당하는 내용을 응답하도록 API를 구성하는 메서드
    
                 @ URL 파라미터 문법('URL/:parameter명')을 사용한 URL 설계
                    : ':parameter명'을 url에 붙임으로서, url값이 입력시 해당 :parameter명 영역의 값을 웹페이지 API 스코프 내부에서 '요청.params'를 통해 JS객체 형식으로 한 큐에 볼 수 있음

                       ex) app.get('/detail/:id', async (요청, 응답) => {
                           
                              // 요청.params를 통해 해당 API에 들어온 url파라미터를 js객체 형식으로 전부 얻을 수 있음.. 그리고 그 중 id라는 parameter명을 pick함 
                              let result = await db.collection('post').findOne({_id : new ObjectId(요청.params.id)});
                              응답.render('detail.ejs', { 상세글 : result })
                           });

                 @ 콜백함수의 내용을 통한 응답내용 메서드
                    a. 응답parameter.send('보내고 싶은 내용')
                        : 해당 express HTTP 메서드의 요청에 대해 화면에 메시지를 보내고 싶은 경우 사용하는 메서드
    
                    b. 응답parameter.sendFile('보내고 싶은 파일경로명')
                        : 해당 express HTTP 메서드의 요청에 대해 파일을 보내고 싶은 경우 사용하는 메서드
                           (= 주로 HTML 파일을 보냄으로서, 화면을 전환할 때 사용함)
    
                    c. (템플릿 엔진 페이지로 전환) 응답parameter.render('EJS파일명.ejs', { ejs파일에서의 DB데이터 변수명 : API내 DB데이터 변수명 , ...  });
                        : 해당 express HTTP 메서드의 요청에 대해 지정한 템플릿 엔진과 받은 DB변수를 사용하여 템플릿 파일을 SSR 렌더링해서 사용자에게 보내라는 명령어
                           (= 템플릿 파일을 렌더링하여 사용자에게 동적으로 웹페이지로 보냄으로서, 화면을 전환할 때 사용함)
    
                    d. 응답parameter.redirect('url명')
                        : 해당 express HTTP 메서드의 요청 프로세스를 다른 API가 처리하도록 떠넘기게 처리 
                          (= 주로 강제로 페이지 이동시키는 사용)
    
                    e. 응답.status(HTTP status 숫자)
                        : 해당 express HTTP 메서드의 요청 프로세스에 응답시 현재 status를 클라이언트에 전달할 때 사용
                           -> 여기에 체인메서드를 통해 .send()메서드로 메시지 보낼수도 있음
    
    
           2) express().http메서드명('*', (요청parameter, 응답parameter) => { 내용 } )
               : express 기반으로 만들어진 서버 객체에 HTTP GET 메서드로 현재 입력된 URL 이외의 내용을 요청하면, 그에 해당하는 내용을 응답하도록 API를 구성하는 promise객체 기반 메서드
    
    
       3. express().use() seris

           1) express().use(express.static(__dirname, '목표 static 폴더 경로(보통은 /public )'));  
               : express.static는 특정 폴더안의 파일들을 static 파일로 지정할 수 있으며, use()메서드를 통해 express 객체가 해당 폴더의 내용을 쓸 수 있도록 등록하는 메서드
    
           [하단의 2개의 코드는 express 환경에서 사용하는 미들웨어로 이를 통해 API에서 요청시 들어온 데이터를 '요청parameter.body' 한 방으로 바로 JS객체로 파싱된 형식으로 볼 수 있음 ]
    
           2) express().use(express.json())
               : express 라이브러리 환경에서 JSON 형태로 들어온 요청(request)의 body 영역을 파싱(parse)하기 위해 사용되는 미들웨어(middleware)
                  -> 이를 사용하지 않을 경우, 템플릿 엔진으로부터 API요청이 들어온 JSON 데이터의 body영역이 인간이 알기 어려운 용어로 전달되거나 예기치 못한 에러가 발생할 수 있음
    
           3) express().use(express.urlencoded())
               : express 라이브러리 환경에서 form태그나 멀티파트 등 JSON 형태가 아닌 URL에 데이터가 포함되어 들어오는 형태로 들어온 요청(request)의 body 영역을 파싱(parse)하기 위해 사용되는 URL 인코딩 관련 미들웨어(middleware)
                  -> 이를 사용하지 않을 경우, 템플릿 엔진으로부터 API요청이 들어온 JSON 이외 데이터의 body영역과 URL에서 얻은 데이터가 인간이 알기 어려운 용어로 전달되거나 예기치 못한 에러가 발생할 수 있음
     
                 # {extended:boolean}
                    : urlencoded 미들웨어에서 전달된 url queryString을 보안 이슈가 있는 중첩 객체를 통해 파싱할건지를 결정하는 설정값
                       -> 'url?데이터명&데이트값' 이런 식으로 사용하는 그 queryString 맞으니 당연히 보안문제가 생긴다는 의미로.. 그래서 보안성 관련 확장을 허용할지 묻는거
                           (= 결과적으로 true, false에 따라 파싱에 사용하는 query String 라이브러리가 달라짐)

                              -> true (기본)  : 객체 형태로 전달된 데이터 내에서 또 다른 중첩된 객체를 허용함 (= body-parser 모듈을 사용가능하게 하는 초석 )
                                                 -> url 쿼리 스트링을 파싱하는데, 따로 설치가 필요하지만 추가적인 보안 확장이 가능한 npm qs 라이브러리 사용함
                                 false        : 객체 형태로 전달된 데이터 내에서 또 다른 중첩된 객체를 허용 X
                                                 -> url 쿼리 스트링을 파싱하는데, node.js에 기본으로 내장된 queryString 라이브러리 사용함
                                               
    
       4. express().set() seris

           1) express().set('view engine', '템플릿 엔진명');
               : express 라이브러리 환경에서 '템플릿 엔진'을 쓸 수 있게 하는 코드 

                  ex) app.set('view engine', 'ejs');