- 로그인 기능 로직
  1. 유저가 가입하면 아이디/비번을 DB에 저장해둠 
  2. 로그인시 아이디/비번을 서버로 보냄 
  3. 서버는 DB에 있는 아이디/비번과 유저가 보낸 아이디/비번이 일치하는 경우 입장권을 발급 
      -> 보통 브라우저의 쿠키로 로그인 관련 데이터를 저장해 둠

 
- 로그인 기능 구현시 사용하는 구현 방식

 1. session 방식
     : 유저가 웹서버에 API를 요청할 때마다 그 session이 유효한지, DB에서 유저가 가진 session id에 따른 유효기간 체크 후 동작을 허락하는 방식
        -> 전통적 방식으로 session 정보는 유저가 로그인할 때마다 DB의 session 테이블에 'id', '날짜', '유효기간', 'session id' 식으로 생성되며, 그 생성한 정보 중 session id만을 클라이언트의 브라우저 쿠키영역에 저장해 줌 

    # session 이란?
       : id : 어쩌구, 유효기간 : 저쩌구 ...  이런 정보를 가진 데이터 뭉치를 의미

    # session의 장/단점 
       (장점) 매번 GET/POST 요청할 때 마다 DB를 조회해보기 때문에, 매 요청마다 엄격하게 유저를 체크
       (단점) 요청이 많은 서비스라면 DB의 부하가 심해짐 (= 조금 더 빠른 메모리 기반 Redis 같은 DB를 쓰기도 하는 이유)

 2. JSON Web Token(JWT) 방식
     : 유저의 로그인 정보가 맞다면 'id', '날짜', '유효기간' 정보를 일부 문자들을 섞은뒤 암호화(일명 hashing)한 Token을 전송하고, 추후 유저가 웹서버에 API를 요청할 때마다 저장된 Token을 디코딩하여 무사히 해독되는게 확인되면 통과시켜 줌
        -> 애초에 session방식의 문제인 api요청때마다 DB에 보내는 session정보 과부하에 따른 단점을 없애고자 만듬
           (= 적법한 사용자인지는 Token을 해독한 뒤 얻은 문자가, 만들 때 넣은 문자와 일치하는지 보는 방식으로 체크)

    # Token 이란?
       : 서버에서 클라이언트로 보내는 메시지이며, 클라이언트가 임시로 저장하는 데이터
          -> 이걸 id, 비번등을 기반으로 특정 문자열과 조합하여 암호화한 json 데이터를 메시지로 보냈다는 점에서.. JSON Web Token이라 함

    # session의 장/단점 
       (장점) 매번 GET/POST 요청할 때 마다 DB를 조회할 필요 X
       (단점) 제대로 만들어진 JWT 자체를 훔쳐서 쓰면 답이 없음.. 훔친거도 디코딩하면 결국 제대로 동작하니.. 그렇다고 이미 주어진 저장된 JWT를 소멸시킬 수도 없음


- hashing(일종의 암호화 알고리즘)
   : 어떤 문제를 알고리즘을 통해 보고 원본을 유추할 수 없는 랜덤한 문자로 바꾸는 작업 자체를 지칭
     (= 이걸 사용하면, DB가 털려도 사용자들의 비밀번호까진 지킬 수 있음... 물론 디코딩 방법을 알면 말짱 도루묵..)
         -> 해싱 방식은 해싱 알고리즘에 따라 다름.. SHA3-256, SHA3-512, bcrypt, scrypt, argon2 등이 존재

             ex) hello ->  SHA3-256 알고리즘으로 X번 hashing -> 3338be694f50c5f338814986cdf0686453a888b84f424d792af4b9202398f392

    # 확장 지식 개념
       1. salt
           : 원본의 추론을 더 어렵게하기 위해서, 어떤 문자열을 hashing하기 전 원본에 '추가문자열'을 붙인 뒤 hashing을 돌리는데, 그 추가된 문자열을 의미
              -> hashing 라이브러리를 쓴다면 이런걸 자동으로 랜덤 지정해주기도 함
              
            @ 장점
              1. 이렇게 되면, 기존에 비밀번호로 사용가능한 문자열 해싱리스트(lookup table attack, rainbow table attack 용도)가 무용지물 됨
              2. hashing된 원본을 해독하는데 성공하더라도, salt에 해당하는 문자열이 뭔지 모르면 의미 없음

       2. papper
           : 사용한 salt들을 모아놓은 보관함을 의미하는 용어


- OAuth 개념
   : 어떤 유저의 A사이트에서의 사용권한을 특정 기능에 한해, 잠시 B 사이트를 운영하는 쪽에서 빌려 A사이트의 API를 호출하는 과정을 정의하는 규칙

      EX) 네이버 로그인, 구글 로그인 같은 소셜 로그인 기능
 
    # OAuth 과정
       1. 유저가 B사이트에서 구글 로그인 버튼을 누르면 구글 계정으로 로그인하라고 뜨는데 로그인 
       2. B사이트에 개인정보 전송해도 되냐고 A사이트에서 유저에게 물어봄
       3. 유저가 허락하면 허락했다고 B사이트 -> A사이트 서버에 알림을 전송 
       4. 알림이 도착하면 A사이트 서버는 B사이트 서버에 유저 정보를 요청하는 API를 사용해서 이를 받아옴
           -> { 유저이메일, 이름, access_token, 유효기간 } 이런 것들이 들어있음
       5. 그 정보들로 JWT 만들어서 사용하거나, session 으로 DB에 저장해두거나 마음대로 한 다음에 로그인기능 구현시 사용 

    # OAuth의 장/단점 

       (장점)
          1. 로그인 기능과 관련해서는 검증된 제 3자의 기술에 의존하니, 어설픈거보다 확실히 낫고 보안 책임이란 짐을 덜 수 있음
          2. 해당 플랫폼이 공공재 수준으로 건재하다면, 대부분의 고객정보 입력이 단축되기에 고객 경험에 유리함

       (단점) 제3자의 사이트에 의존하는 방법이라는 근본적인 한계가 존재
          1. 그 플랫폼의 인기가 떨어지면, 다른 곳을 찾아야 함
          2. 해당 플랫폼 서버에서 검증을 거치기에, 거기에 문제 생기면 로그인 기능도 맛탱이가 감 

- DB관련 웹서비스 성능 관련 TIP (= 어떻게든 DB를 향한 요청의 과부하를 줄여야 한다면?)
   1. HDD보다 반응이 빠른 RAM기반 데이터베이스를 쓰는거도 좋다 (ex. Redis)
   2. DB조회할 필요없는 JWT를 적극 도입해봐라
   3. deserializeUser를 정말 필요한 특정 route(페이지나 API)에서만 실행시킨다면, 필요없는 DB조회를 감소시켜 트래픽 감소와 성능향상에 영향을 줄 수 있음