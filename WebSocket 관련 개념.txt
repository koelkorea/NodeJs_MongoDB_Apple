- 서버와 클라이언트가 통신하는 3가지 방법

 1. 일반 HTTP 메서드를 통한 API 요청 (클라이언트에서 일방적 호출)
     : GET, POST, PUT, PATCH, DELETE 등의 HTTP 메서드 종류를 특정 URL과 조합함으로서 서버에 API를 호출하여 요청을 보내는 방법
        -> HTTP 메서드는 대충 큰 틀의 용도를 알려주는 느낌에 가깝고, 서버측에서도 같은 URL을 HTTP 메서드 종류만 바꾸면 다른 URL처럼 사용할 수 있기에, API 제작에 있어 URL명칭 짓기가 수월해짐
    
     # 특징
        1) 2.0은 절차가 다 짜여져 있는 TCP/IP 기준, 3.0부터는 상대적으로 유저 꼴리는데로 가볍게 커스텀이 가능한 UDP를 씀
        2) a태그나 form태그를 통한 호출로는 GET, POST 기반 API 밖에 호출이 불가능함
        3) (중요) 클라이언트 측에서 먼저 호출을 보내야 서버는 응답한다는 '수동성'이 매우 강함 
           (= 유저가 움직이지 않으면 화면갱신이 안되는 서비스 뿐이 못 만듦)


 2. Server sent events (서버가 일방적 전달)
     : 서버에 한번 연결해두면 서버가 원할 때 맘대로 데이터를 유저에게 보내줄 수 있는 라디오 같은 서버 to 클라이언트 일방향 통신법
       (= 유저는 그냥 라디오 듣듯이 일방적으로 서버가 주는걸 받기만 할 수 있다..)
           -> 가벼운 데이터를 일정한 간격으로 클라이언트 측에 전달해야 할 떄 유용함 

     # 사용법
        : server sent events 쓰겠다고 서버에 HTTP요청을 날리면, 서버에서 server sent events로 업그레이드해주는 식으로 사용
           ex) 서버에서 계속 유저에게 데이터를 푸시하여 새로고침해주는 주식창 

 3. Websocket (서버 - 클라이언트 간 양방향 통신 가능)
     : HTTP 메서드, Server sent events의 단방향 통신이라는 치명적인 단점을 해결하여, 양측 모두가 주도적 통신이 가능한 전화 같은 통신법

     # 사용법
        : Websocket 쓰겠다고 서버에 HTTP요청을 날리면, 서버에서 Websocket로 업그레이드해주는 식으로 사용
           ex) 채팅기능, 게임기능같은 실시간 양방향 통신의 구성이 필요한 경우 사용

 4. (참고) long polling
     : 서버가 응답할 때 마다 유저측에서 다시 HTTP 요청을 날려서 실시간 데이터를 계속 받아내는 테크닉에 가까운 방법
       (= 유저가 서버로 HTTP 요청을 처음 날릴 때는 서버는 일단 기다린 뒤, 거기서 새로운 내용이 들어올 때 응답.어쩌구()를 날려줌)

     # 특징
        1) 실시간 메세지가 적을 때 유용
        2) Node.js로 서버 런타임 환경을 구축하면 써도 됨
           (= 다른 서버 환경에서 응답 칼같이 안하면, ram 용량 초과로 인해 서버 다운될 위험이 존재할 수도 있음)


- socket.io 
   : express 프레임워크에서 가장 많이 쓰는 websocket 관련 라이브러리로 사용이 손쉽고 간편하다는게 장점
      -> Node.js에서 순정으로 지원하는 ws라는 라이브러리도 존재함

      # socket.io 설치 및 세팅하기
         1) npm install socket.io@4 를 입력하여, socket.io 라이브러리 설치
         2) 보일러 플레이트를 server.js에 추가
             : (중요) new Server(createServer(express()))는 서버에서 클라이언트로 웹소켓을 연결하고 초기화한 뒤 해당 객체를 io 변수에 저장함
               (= new Server()를 통해 서버 -> 클라이언트 웹소켓 소통 가능)

               const { createServer } = require('http')
               const { Server } = require('socket.io')
               const server = createServer(app)
               const io = new Server(server) 

         3) DB서버 연결 관련 함수 listen()을 그냥 express() 기반에서, socket.io가 사용가능한 형식의 createServer(require('express')) 기반으로 변경
             -> express().listen() -> server.listen()으로 변경
                (= server = createServer( express() ) )

                ex) server.listen(process.env.PORT, () => {
                      console.log('http://localhost:8080 에서 서버 실행중')
                    })

         4) 클라이언트가 웹소켓 연결시, 서버에서 코드를 실행하기 위해서 server.js에 io.on('connection', 무명콜백함수 ( socket ) => { 내용 })을 입력하고, 클라이언트에서 선택하는 '데이터명'에 따른 분기처리문을 써줌
             -> 하단의 io.on('connection', 무명콜백함수 ( socket ) => { 내용 } ) 내용 참고 바람

         5) 웹소켓 사용을 원하는 화면(html, jsx, ejs 등) 파일에도 script 태그를 넣어서 socket.io 라이브러리를 연결
             -> <script src="https://cdn.jsdelivr.net/npm/socket.io@4.7.2/client-dist/socket.io.min.js"></script>
         
         6) (중요) 화면(ejs) script 태그에서 const socket = io()을 통해, 화면에서 서버로 웹소켓을 연결하고 초기화한 객체를 socket 변수에 저장함


      # (중요) room 개념과 함수 사용법
         : room은 유저들이 입장할 수 있는 일종의 웹소켓 방과 같은 개념
            -> 특정 room에 있는 유저들에게만 메세지 전송하라는 코드를 짜는것이 가능하게 함
               (= 채팅방에 있는 사람들에게만 채팅 메시지를 보내는게 가능)


      # socket.io 사용하여 양방향 소통하는 함수를 사용하여 socket.io를 사용한 api 작성법
         : server.js와 화면.ejs에서 웹소켓을 연결하는 키워드는 io라고 보면 됨
            -> server.js : new Server(createServer(express()))로 웹소켓에 연결하고 초기화한 결과를 io라는 js변수가 받음
            -> 화면.ejs : io() 함수로 웹소켓에 연결하고 초기화한 결과를 server라는 js변수가 받음

               1. (server.js) 
                    : const io = new Server( createServer( express() ) ) 기반
                      (= server.js에서 사용되는 변수 = 서버가 소통의 시작(= 서버 -> 클라이언트)이라는 의미를 암시)
 
                      1) io.on('connection', 무명콜백함수 ( socket ) => { 내용 } )
                          : 클라이언트가 웹소켓 연결 및 새로운 내용의 데이터를 수신한걸 감지할 때, 서버에서 특정 코드를 실행하고 싶은 경우의 내용을 무명콜백함수에 넣어 사용

                           @ (중요!) 무명콜백함수의 parameter socket ( <-> (중요) 화면.ejs에서 사용하는 io()를 받는 변수 socket)
                              : socket.io에 내장된 블랙박스인 클라이언트로부터 데이터 수신시에 이를 받고 처리할 목적으로 실행되는 'websocket 객체' 그 자체
                                 -> 클라이언트와의 실시간 데이터 수신 자체는 무명콜백함수를 통해 paramter로 삽입된 해당 socket를 매개로 socket의 메서드들을 실행하여 이뤄짐

                                    a. socket.on('클라이언트가 붙인 데이터명', (클라이언트로부터 받은 data 객체 parameter) => { 내용 }
                                        : 클라이언트에게서 서버가 '데이터명'이란 이름으로 보내진 내용의 데이터를 '수신'하게 되면, 그 수신한 data를 parameter로 받아 가공한 무명콜백함수 ( 클라이언트로부터 받은 data 객체 parameter ) => { 내용 } 를 실행해 주는 API에 해당
                                          (= io.on() 안에 여러가지의 데이터명을 받을떄를 대비한 API에 해당하는 socket.on() 기입은 자유로히 가능함)
                                              -> (중요) 서버의 io.on('connection', (socket) => { 내용 } )안에는 클라이언트가 기입한 '데이터명'들에 따라 어떻게 반응할지에 대한 경우의 수만큼 socket.on('데이터명', (data) => { 내용 }이 작성됨

                                    b. socket.join('대상 room이름') 
                                        : 클라이언트가 서버가 socket.on() 에 상정한 특정 '데이터명'(개발자 마음대로 지어도 됨)으로 요청을 먼저 보낸다면 
                                           -> 서버는 그 클라이언트를 '대상 room이름'으로 되어있는 'room의 멤버로 해당 클라이언트를 끼워줌'
                                              (= 서버는 room에 있는 클라이언트들을 구분하여, 데이터를 보낼 수 있음)
                                           -> (중요!) 전송결과에 대한 반환값은 없음 (= undefined)

                                    c. socket.request.session
                                       : passport 라이브러리 사용시 socket.io와 연계하여 로그인 정보에 해당하는 쿠키를 전송하는 미들웨어를 실행하여 서버에 보내면, 서버가 쉽게 클라이언트의 로그인 정보를 출력가능하게 되는 객체 속성
                                         (= 메세지 보내는 유저가 누구인지 확인하고 그걸 웹소켓 기능에 응용할 수 있다는 것)
                                            -> https://socket.io/how-to/use-with-express-session 참고하여 실행하면 사용 가능

                           @ (중요) 참고사항 및 특성  
                              [1] data.멤버변수 
                                   : 클라이언트 측에서 보낸 데이터를 2개 이상의 멤버변수들이 존재하는 js객체 타입으로 서버에 보냈으면, 구체적인 멤버변수를 지정해서 무명콜백함수의 내용을 작성해야함
                                     (= 1개의 데이터를 개별로 보냈으면, 그냥 data로 참고 및 접근이 가능함)

                              [2] socket.join('대상 room이름')에 대한 room 생성요구 승인 및 실행에 대한 반환값은 성공여부와 관련없이 undefined
                              [3] io.emit('서버가 붙인 데이터명', '서버가 보낸 메세지')의 전송결과에 대한 반환값은 boolean
                                  (= 전송 성공결과에 따라 true/false로 분기)

                      2) io.emit('서버가 붙인 데이터명', '서버가 보낸 메세지') 
                          : ('서버 -> 모든 클라이언트') 서버에 모든 연결된 '모든' 클라이언트들에게로 어떤 데이터를 웹소켓으로 전송하고 싶을때 사용
                              -> (중요) 전송결과에 대한 반환값은 boolean 값 (= 전송 성공결과에 따라 true/false로 분기)

                      3) io.to(data.room).emit('서버가 붙인 데이터명', data.msg) 
                         : ('서버 -> 특정 room의 클라이언트') 클라이언트가 요청한 data.room안의 '특정 room'의 클라이언트들에게로 data.msg 데이터를 웹소켓으로 전송하고 싶을때 사용                         
                              -> (중요) 전송결과에 대한 반환값은 boolean 값 (= 전송 성공결과에 따라 true/false로 분기)

                          @ 해당 함수는 io.on('connection', ( socket ) => { socket.on('데이터명', ( data ) => { 내용 } ) } ) 과정에서 마지막 내용으로 들어가기에
                             -> data 객체는 socket.on()의 무명콜백함수의 paramter로 들어간 클라이언트가 보낸 정보에 해당하는 객체라고 보면 됨
                                 -> data.room or data.msg가 무엇인지는 하단 io().emit('데이터명', { msg : '메세지내용', room : '대상 room' } ) 을 참고하라

               2. (화면.ejs) 
                    : const socket = io() 기반
                      (= 화면.ejs의 script 태그 내에서 사용되는 변수 = 클라이언트의 화면(= 클라이언트 -> 서버)이 소통의 시작이라는 의미를 암시)

                      1) io().on('클라이언트가 붙인 데이터명', 무명콜백함수 ( 서버로부터 받은 데이터 객체 parameter ) => { 내용 } )
                          : 서버에서 보낸 메세지나 데이터를 '수신'한 뒤, 그를 기반으로 클라이언트에서 특정 코드를 실행하고 싶은 경우 사용

                      2) io().emit('클라이언트가 붙인 클라이언트 측에서 붙인 데이터명', '데이터')  
                          : ('클라이언트 -> 서버') 클라이언트가 웹소켓으로 어떤 데이터를 서버로 전송하고 싶을떄 사용

                      3) io().emit('클라이언트가 붙인 클라이언트 측에서 붙인 데이터명', { msg : '메세지내용', room : '대상 room' } ) 
                          : ('클라이언트 -> 서버') 클라이언트가 특정한 '대상 room'에 소속된 다른 클라이언트들에게 웹소켓으로 '메세지내용' or 데이터를 실시간으로 보내달라고 서버에 요청할 때 사용
