- DB(DataBase)
   : 데이터를 대량으로 영구적으로 보관 + 그 데이터를 빠르게 입/출력 하는데 특화 + 여러 사용자가 공유하여 사용할수 있는 통합해서 저장한 운영 데이터의 집합
      -> 일반적으로 데이터베이스 관리 시스템(DBMS)에 의해 제어

     # 관계형을 기준으로 본 DB의 종류
        1. 관계형 데이터베이스 (RDBMS)
            : 각 데이터들이 1개 이상의 '행 : 열' = 'key : value' 관계로 이뤄진 테이블 형식의 스키마에 저장되어 있는 DB
              (= 각 테이블 간 다른 데이터 구조가 어떻게 관련되어 있는지 외래키(= Foreign Key)를 기준으로 명확하게 정규화되어 정의되어 있기에, 쉽게 파악하고 이해 가능)
                  -> 정규화(normal form) 되어 있기에, 데이터 입/출력의 정확도가 뛰어난 편

                      EX) MySQL, PostgreSQL, Oracle, SQLite, MSSQL
                           -> 아주 대부분의 프로젝트들이 사용하는 DB들이 다 여기 있으며, SQL 사용

        
        2. 비관계형 데이터베이스 (NoSQL)
            : 1과 같은 테이블 형식의 스키마를 사용하지 않는 DB
              (= 명확하고 정확도는 기대 못하지만? 자유롭게 이용가능하며, JSON형식과 유사하게 사용 가능)
                  -> 정규화 안해도 되서 단순하고 빠르지만, 데이터 입/출력이 정확하지 않아, 정교한 조직이나 수정이 힘들다

                      EX) MongoDB, Redis

     # 정규화 여부를 기준으로 본 DB의 종류
        1. 정규화 데이터베이스(normalized database)
            : 데이터 간 중복을 최소화하도록 설계된 DB
               -> 공간적으로는 효율적이지만, 시간적으로는 수시로 JOIN처리를 해야해서 상대적으로 느린 단점이 존재
        
        2. 비정규화 데이터베이스(denormalized database)
            : 읽는 시간을 최적화하도록 설계된 DB
               -> 공간적으로는 비효율적이지만, 시간적으로 빠르고 규모 확장성이 높다는 장점이 존재하며


- index(인덱스) 개념
   : 어떤 DB의 table(= collection) 데이터들을 어떤 정렬기준을 가지고 정렬시켜 놓은 버전의 복사본
       -> 이를 기반으로 DB의 데이터들을 조건에 맞게 검색하고 뽑는 작업속도와 효율을 늘리는 목적으로 제작함

      # index의 특징
         1. (중요) 보통 검색에 사용하는 알고리즘은 '이진검색(binary search)'이거나 그보다 빠른 알고리즘으로 시간복잡도는 O(log n)보다 빠르다고 보면 됨
         2. index에 반영된 필드(= 칼럼)이 여러가지인 compound index도 존재함
         3. (MongoDB 한정) 각 Collection은 기본적으로 _id 순으로 정렬해둔 index가 있음

      # index의 단점
         : 어쨌거나 편리한 만큼 공간적 시간적 댓가가 필요하니, 검색작업이 많은 필드들만 index 만들어두는게 비용적으로 이득

            1. 결국 하드웨어에 이를 저장할 용량을 필요로 함
               (= index는 정렬기준을 가지고 정렬시켜 놓은 버전의 복사본)
   
            2. collection(= table)의 document(= data)의 CUD시 index에도 이를 반영해줘야 함
               (= index가 너무 많으면, CUD 작업할 때마다 동반되는 작업이 너무 많음)

            3. (mongoDB 한정) 문자(= text)로 정렬한 index는 정확한 단어 검색에 밖에 사용이 불가능 (= 조사가 많이 붙는 언어들은 쓰기가 힘듦)
                  -> index 제작시 데이터들을 띄어쓰기를 기준으로 독립된 단어들로 구분한 뒤, 검색어와 100% 일치하는 단어가 있는지 없는지 여부로 검색을 수행하기 때문
                      -> full text index (= search index) 라는 개념이 필요

      # search index (= 타 DB에서 full text index) 개념
         : MongoDB에서 문자를 100%가 아니라 부분적으로 포함될 경우라도 검색결과에 포함할 용도로 만들어진 index 
           (= 일반적으로 생각하는 검색기능에 부합할 수 있도록 제작된 정렬기준으로 제작된 index)

           @ search index 제작과정 및 동작 원리
              1. index를 만들 때 document(= 데이터)에 있는 특정 칼럼(= 필드)에 있는 문장들을 가져와서 조사, 부호 등 쓸데없는 불용어들을 다 제거

                  ex) 영어 기준   : 문장의 단어 중 and or the ~s 
                  ex) 한국어 기준 : 을, 를, 이, 가, 그리고, 또는 

              2. 1번의 과정을 거쳐 등장한 단어들을 다 뽑아서 정렬한 목록 제작
                 (= 해당 단어들을 목록에서 쉽게 빠르게 찾을 수 있으며, 이를 3번과정에서 부분검색기능에 활용하도록 하는 포석)

              3. 2번의 목록에서 해당 단어들이 어떤 document에 등장했는지와 연관된 필드를 만들고, 해당 단어가 등장한 document id같은걸 함께 단어 옆에 기재
              4. 검색을 하면 해당 index 목록을 참고하여, 검색어에 따른 document를 찾아서 클라이언트 측에 제공
                  -> seafood chicken 이렇게 검색하면, seafood와 chicken을 earch index에서 각각 검색하여, 그것이 존재하는 document를 도출하고, 이를 검색함수 find에 넣어서 결과를 도출해 클라이언트 측에 제공 
              
                     ex) <document>
                          _id : 1
                          title : Seafood and restaurants

                          _id : 2
                          title : Seafood and chicken

                          _id : 3
                          title : the game reviews~!

                         <제작된 search index>
                          단어         존재하는 docu ID
                          chicken      2
                          game         3
                          restaurant   1
                          review       3
                          seafood      1, 2                <- seafood를 검색한다면, 그것이 _id 1, 2에 존재한다는걸 알수 있기에, 이를 검색함수 find에 넣어서 결과를 도출해 클라이언트 측에 제공

           @ search index 특징
              1. 찾아온 document가 좀 많으면 내부적으로 중요해보이는 document들을 맨 위로 올려서 가져와줌
              2. 검색어 자동완성기능, 유사단어 검색기능 이런 것도 설정 가능


- 정규화(Normalized)와 비정규화(denormalized) 
   : 대부분의 규모 확장성(scalability)을 요구하는 시스템의 경우, 여러가지 이유로 2가지를 혼용하여 섞어 사용

     1. 정규화(Normalized)
         : (관계형 데이터베이스 (RDBMS)에서만 사용 가능) DB를 구성하는 테이블(= collection)들의 칼럼(= field)구성에 있어, 중복성과 종속성을 줄이는 최소화하기 위해 데이터를 구조화하여 정규형(normal form)로 만드는 작업
            -> 테이블과 테이블의 중복저장되는 종류의 데이터를 가지는 칼럼들이 존재하는 낭비와 그런 데이터들이 부분적인 갱신으로 인한 문제를 해결하고자 도입하는 것
   
           # (중요) 구체적으로 어떻게 구현?
              1) 테이블들을 관리하기 쉬운 작은 테이블들로 나눈 뒤
              2) 쪼개진 각 테이블의 데이터들은 중복되지 않고, 서로를 구분 가능한 주요 속성을 가진 칼럼인 기본 키(= Primary key)를 가지고 있어야 함
                  -> 제 1 정규화(= 1NF)
              3) 쪼개진 각 테이블의 기본 키(= Primary key)가 아닌 비주요 칼럼들은 기본 키(= Primary key)와 직접적으로 의미적인 종속관계를 가져야 함
                  -> 제 2 정규화(= 2NF)
              4) 3)의 비주요 칼럼들은 제 각각 서로간 어떠한 종속관계를 의미적으로 가지는 경우가 있다면, 그 칼럼들중 일부는 관계성이 사라질 때까지 테이블에서 퇴출되어야 함
                  -> 제 3, 4 정규화(= 3NF)
              5) (중요!) 쪼개진 테이블 간 관계성을 가지는 경우는, 테이블 간 연결되는 데이터 칼럼인 Foreign Key(= 외래키)을 생성하여 해결
                  -> 제 5 정규화(= 5NF)
                  -> 이를 통해 필요하고 연관된 다른 테이블의 칼럼값들을 전부 데이터로 뽑을 수 있게 함
                     (= 이 과정에서 이용하는 방식이 2개의 테이블을 참조하고, 거기서 공통값들을 조건을 통해 뽑아내는 join과 같은 방법은 관계형DB에서만 가능)    
   
           # 정규화의 원칙
              1) 정보의 무손실 표현 
                  : 스키마를 다른 스키마로 변환할 때, 정보의 손실이 있어서는 안 됨
                    (= 정규화의 결과로 JOIN을 해도 원본 데이터가 소실되지 않고 가져올 수 있는 방향으로 DB설계를 해야 함)
   
              2) 분리의 원칙 (2NF, 3NF 관련)
                  : 테이블에 PK와 관련없거나, 있더라도 다른 nonPK와 연관이 있는 칼럼들은 독립된 테이블로 분리해놔야 함
   
              3) 데이터의 중복성이 감소되어야 함 (1NF 관련)
   
           # 정규형(normal form)의 단계
              : DB 설계에 있어 어떤 조건을 만족했는지에 따라, 정규화의 수준이 주로 3단계로 나눠지며, 높은 단계일수록 정규화가 잘된것을 의미함
                (= 3단계가 되면 4, 5 단계는 거의 만족하는 곁다리에 가까움)
                
                1) 1정규형 (1NF)
                    : DB의 각 테이블 모든 칼럼은 반복 그룹이 존재해서는 안되며, 원자적인 값(= 1개의 값)을 가지고 있어야 한다는 원칙
                      (= 여기서, 대부분의 중복, 반복적으로 흘러가는 부분들은 전부 다듦을수 있음)
      
                       ex) 제 1 정규형 (1NF) 충족 X
                            : 고객명, 주문상품 칼럼에 들어간 데이터가 복수개이기 때문
      
                              주문번호 |    고객명     |   주문상품           ->    주문번호 | 고객명 | 주문상품
                                 1    | 홍길동, 김철수 | 사과, 바나나                  1    | 홍길동 |   사과   
   
                       ex) 제 1 정규형 (1NF) 충족 X
                            : 회원번호, 고객명, 별명에 반복되기에, 반복되는 부분을 다른 테이블로 나누어 원래 존재하는 부분의 칼럼수를 줄임
      
                              주문번호 | 회원번호 |  고객명 | 별명 | 주문상품           ->    회원번호 | 고객명 | 별명
                                 1    |    1    |  홍길동 | 악마 |   사과                      1    | 홍길동  | 악마
                                 2    |    1    |  홍길동 | 악마 |  바나나                     2    | 김철수  | 사람
                                 3    |    2    |  김철수 | 사람 |   사과         
                                                                                           주문번호 | 주문상품 | 회원번호
                                                                                              1    |   사과   |    1
                                                                                              2    |  바나나  |    1
                                                                                              3    |   사과   |    2
                2) 2정규형 (2NF) (= 부분 종속 제거)
                    : DB의 각 테이블은 서로 구분 가능한 주요 속성을 가진 칼럼인 기본 키(= Primary key)를 기준으로 모든 비주요 속성에 해당하는 칼럼들이 의미적으로 완전히 종속되어야 함
                      (= 테이블의 개념 주체는 기본 키(= PK)를 가진 칼럼을 기준으로 나머지 칼럼들이 의존하는 의미를 가져야 한다는 것)
      
                       ex) 제 2 정규형 (2NF) 충족 X
                            : 주문 테이블의 기본키(= PK)를 가진 칼럼은 주문번호로 이는 주문을 구분하는 주요개념이나..
                              BUT! 가격 정보를 나타내는 칼럼은 주문 테이블의 기본키(= PK)값을 가진 주문번호에 의미적으로 종속X, 상품명이 무엇인지에 따라 달라지는 값을 가진 개념
                               -> 상품 테이블을 따로 만들고, 상품 테이블의 기본키(= PK)는 상품명 칼럼을 지정하여, 상품명을 주요 속성 개념으로 정의하며, 주문 테이블과의 관계는 주문 테이블의 상품명 칼럼을 외래키(= FK)로 지정하여 주문 테이블과 연결해 해결
   
                              주문번호 | 상품명 |  가격             ->    주문번호(PK) | 상품명(FK) 
                                 1    | 사과   |  1000                      1        | 사과
                                 1    | 바나나 |  1500                      1        | 바나나
   
                                                                        상품명(PK, FK) | 가격
                                                                              사과     | 1000
                                                                             바나나    | 1500
                3) 3정규형 (3NF) (= 이행 종속 제거)
                    : DB의 각 테이블의 모든 비주요 속성에 해당하는 칼럼들과 테이블의 기본 키(= Primary key)와 의미적인 종속관계인 2정규형(= 2NF)을 만족한다 쳐도, 비주요 속성 간 종속성들이 존재(= 이행적 종속)한다면 이는 제거되어야 함
                      (= 2정규형을 만족하는 DB설계에서 각 테이블의 비 PK칼럼들간 종속성이 보이면 이거도 모두 제거해야 함)
   
                    서로 구분 가능한 주요 속성을 가진 칼럼인 기본 키(= Primary key)를 기준으로 나머지 모든 비주요 속성에 해당하는 칼럼들이 의미적으로 완전히 종속되어야 함
                      (= 테이블의 개념 주체는 기본 키(= PK)를 가진 칼럼을 기준으로 나머지 칼럼들이 의존하는 의미를 가져야 한다는 것)
   
                          ex) 제 3 정규형 (3NF) 충족 X
                            : 부서명, 부서위치 모두 직원 테이블의 기본값(= PK)를 가진 칼럼인 직원번호와 종속적 관계지만..
                              BUT! 비주요 속성 칼럼인 부서위치, 부서명은 부서위치가 부서명에 다른 한편으로 또 종속성을 가짐
                               -> 부서 테이블을 따로 만들고, 부서 테이블의 기본키(= PK)는 부서명 칼럼을 지정하여, 부서명을 주요 속성 개념으로 정의하며, 사원 테이블과의 관계는 사원 테이블의 부서명 칼럼을 외래키(= FK)로 지정하여 부서 테이블과 연결해 해결
   
                              직원번호 | 부서명 | 부서위치             ->    직원번호 | 부서명
                                101   | 판매부 |  서울                        101   | 판매부
                                102   | 회계부 |  부산                        102   | 회계부 
   
                                                                            부서명 | 부서위치
                                                                            판매부 |  서울
                                                                            회계부 |  부산
   
                4) (안 중요) 4정규형 (4NF)
                    : DB의 각 테이블들은 다치 종속성(= 1개의 칼럼의 데이터가 다른 칼럼의 데이터와 1:N으로 대응하는 경우)을 없애야 함
                       -> 데이터들의 원자화 1정규형, non PK 칼럼들은 모두 PK칼럼에 의미적 종속관계 성립의 2정규형, 그 외 모든 non PK들 간의 종속성 삭제의 3 정규형을 모두 거치면 당연히 이런 경우는 사라짐
   
                5) (안 중요) 5정규형 (5NF)
                    : DB의 모든 테이블과 칼럼들이 조인 종속성(= )까지 제거되어, 이 이상으로 쪼개거나 나누면, 오히려 문제가 생기는 형태를 의미
                       -> 쉽게 말해, 존재하는 모든 테이블에 FK값을 통해 원래 존재했던 모든 형태로 데이터를 복원이 가능하게 설계된 경우라고 생각하면 됨
   
           # 정규형(normal form)의 장/단점
   
              @ 장점
                 1) 비정규화 DB는 겪는 이상 현상(Anomaly)이라는게 없음
                 2) 저장 공간의 최소화
                 3) 효과적인 검색 알고리즘 생성
                 4) 테이블간 칼럼 간 이미 구조가 최적화 되었으니, 데이터 투입에 별 고민 안해도 됨
                 5) 데이터 구조의 안정성 및 무결성 유지
   
              @ 단점
                 1) 뭐 할때마다 JOIN 연산이 필요한 경우가 많음
                    (= 이로 인한 질의에 대한 응답 시간 저하)
   

     2. 비정규화(Denormalized)
         : 의도적으로 정규화 원칙을 위배하여 JOIN ㅈ까는 방향으로 테이블의 칼럼을 배치하는 DB설계 과정을 의미
             -> 테이블 간 중복, 반복되는 데이터가 보이더라도 개발이던 DB성능이건 속도라는 관점에서 다 용서하는 관점에서 진행함
                (= join을 상정하지 않기에, 애초에 join 기능 사용이 불가능함.. 따라서 테이블(=collection)에 필요한건 다 때려넣는다는 각오가 있어야 함)
               
   
                ex) 이런식으로 고객명, 별명이 중복, 반복되어도 전부 허용함... 애초에 join을 상정한거도 아님
   
                    주문번호 | 회원번호 |  고객명 | 별명 | 주문상품           ->    회원번호 | 고객명  | 별명
                       1    |    1    |  홍길동 | 악마 |   사과                      1    | 홍길동  | 악마
                       2    |    1    |  홍길동 | 악마 |  바나나                     2    | 김철수  | 사람
                       3    |    2    |  김철수 | 사람 |   사과         
   
           # 비정규화 대상
              : 그러니까 기술적으로 JOIN처리하기 힘들고, 처리 범위도 넓고 사용 빈도도 높아서 정규화보단 닥치고 성능이 중요한 부분이 주요 타겟

                1) 자주 사용되는 테이블에 액세스하는 프로세스의 수가 가장 많음
                2) 항상 일정한 범위만을 조회하는 경우
                3) 테이블에 대량 데이터가 있고 대량의 범위를 자주 처리하는 경우, 성능 상 이슈가 있을 경우
                4) 테이블에 지나치게 조인을 많이 사용하게 되어 데이터를 조회하는 것이 기술적으로 어려울 경우

           # 정규형(normal form)의 장/단점
   
              @ 장점
                 : JOIN X라 성능, 복잡성 부분에서 이득
                     -> 빠른 데이터 조회
                     -> 살펴볼 테이블이 줄어들기 때문에 데이터 조회 쿼리가 간단
                        (= DB 설계시간 단축으로 개발속도 빠름 + 버그도 줄어듦)
   
              @ 단점
                 1) 이상 현상(Anomaly) 발생에 따른 문제
                     - 데이터 갱신이나 삽입 비용이 높음
                     - 데이터 갱신 또는 삽입 코드를 작성하기 어려워짐
                     - 데이터 간의 일관성, 무결성이 깨어질 수 있다. 어느 쪽이 올바른 값인가?
   
                 2) 데이터를 중복하여 저장하므로 더 많은 저장 공간이 필요
   
           # 이상현상(Anomaly)
              : 중복된 정보로 인해 발생하는 문제로... 정규화를 통해서 밖에는 해결이 불가능함! 
                (= 비정규화 DB쓰면 절대 헤어나오지 못함)
   
                1) 입력 이상(Insertion Anomaly)
                   : 원하지 않는 자료가 입력 or 입력하는데 자료가 부족해 삽입이 되지 않아 발생하는 문제점
                
                2) 삭제 이상(Deletion Anomaly)
                   : 하나의 자료만 삭제하고 싶지만, 그 자료가 포함된 튜플 전체가 삭제됨으로 원하지 않는 정보 손실이 발생하는 문제점
                
                3) 갱신 이상(Modification Anomaly)
                   : 정확하지 않거나 일부의 튜플만 갱신되어 정보가 모호해지거나, 일관성이 없어져 정확한 정보 파악이 되지 않는 문제점
                      -> 비정규화 DB를 쓰다보면, 이 문제가 참 골칫거리임

- change stream 개념
   : DB의 변동사항이 생길 경우 이를 웹서버에 실시간으로 알려주는 개념의 기능
     (= DB가 웹서버에서 명령하는 대로 데이터 입출력만 하는 것을 넘어, 실시간 능동적으로 데이터를 보내는 능동성을 가지게 됨)

     # change stream 특징
        1. (중요!) DB에서만 능동적으로 실시간 데이터를 보내도 웹서버 또한 능동적으로 클라이언트 측에 데이터를 보낼 수 있어야 의미가 생김
             -> 웹서버 측도 능동적으로 클라이언트에 데이터를 전송가능한 웹소켓이나 Server sent event와 같은 기술을 활용할 수 있어야 함
                 -> 자세한 건, 웹소켓과 SSE관련 문서들을 참고
                 
        2. 보통 관계형 DB들은 binlog나 CDC 같은거 찾아봐야 하는 경우가 많음
            -> MongoClient Nodejs 라이브러리는 client.db('프로젝트명').collection('컬랙션명').watch('조건' or 조건변수) 를 사용시 체크 가능
                -> 자세한 건, client.db('프로젝트명').collection('컬랙션명').watch('조건' or 조건변수) 참고


- validation 개념
   : DB에 저장할 데이터 검증하는 방법 (validation)

     1. server.js에서 CUD 실행전 if문을 통해 들어올 수 있는 데이터들을 경우의 수를 마련하여 차단 
     2. MongoDB native 라이브러리의 자체 schema validation 기능을 사용하여, 잘못된 타입의 데이터 입력 원천 차단하기
         -> https://www.mongodb.com/docs/manual/core/schema-validation/ 참고
  
     3. 타입스크립트를 사용하여 해결
     4. 관련 라이브러리를 사용하여 해결
     
        ex) express-validator
            : express 프레임워크 사용시, API의 미들웨어 형식으로 validation 기능을 수행해주는 라이브러리  
  
     5. 애초부터 Mongoose를 사용해서 타입 정의 관련 이득을 봄
     6. JavaDoc과 같이 JS에서도 주석을 통해 객체 내부 멤버변수들의 타입 힌트를 적어둘 수 있는 JSdoc 사용
         -> 변수나 함수 위에 /** 주석 */ 을 달아서 타입 힌트를 넣으면, 자동으로 밑에 있는 변수나 함수에 타입힌트를 제공

             ex) /** @type { { title : string, content : string } }  */
                 let result = await db.collection('post').findOne({_id : 1})

                 /** @type { { title : string, content : string }[] }  */
                 let result = await db.collection('post').find().toArray() 